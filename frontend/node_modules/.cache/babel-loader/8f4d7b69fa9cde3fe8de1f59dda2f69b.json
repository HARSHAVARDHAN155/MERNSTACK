{"ast":null,"code":"/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\"use strict\";\n\n(function () {\n  var MOZ_TO_ME = {\n    Program: function (M) {\n      return new AST_Toplevel({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: normalize_directives(M.body.map(from_moz))\n      });\n    },\n    ArrowFunctionExpression: function (M) {\n      var argnames = [],\n          rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        argnames: argnames,\n        rest: rest\n      });\n      var node = from_moz(M.body);\n\n      if (node instanceof AST_BlockStatement) {\n        fn.body = normalize_directives(node.body);\n        fn.value = null;\n      } else {\n        fn.body = [];\n        fn.value = node;\n      }\n\n      return fn;\n    },\n    FunctionDeclaration: function (M) {\n      var ctor;\n\n      if (M.async) {\n        ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n      } else {\n        ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n      }\n\n      var argnames = [],\n          rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: argnames,\n        rest: rest,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    FunctionExpression: function (M) {\n      var ctor;\n\n      if (M.async) {\n        ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n      } else {\n        ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n      }\n\n      var argnames = [],\n          rest = null;\n      M.params.forEach(function (param) {\n        if (param.type == \"RestElement\") {\n          rest = from_moz(param.argument);\n        } else {\n          argnames.push(from_moz(param));\n        }\n      });\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: argnames,\n        rest: rest,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    ClassDeclaration: function (M) {\n      return new AST_DefClass({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        extends: from_moz(M.superClass),\n        properties: M.body.body.map(from_moz)\n      });\n    },\n    ClassExpression: function (M) {\n      return new AST_ClassExpression({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        extends: from_moz(M.superClass),\n        properties: M.body.body.map(from_moz)\n      });\n    },\n    MethodDefinition: function (M) {\n      var key = M.key,\n          internal = false;\n\n      if (M.computed) {\n        key = from_moz(key);\n      } else if (key.type == \"PrivateIdentifier\") {\n        internal = true;\n        key = \"#\" + key.name;\n      } else {\n        key = read_name(key);\n      }\n\n      var ctor = AST_ClassMethod,\n          value = from_moz(M.value);\n\n      switch (M.kind) {\n        case \"get\":\n          ctor = AST_ClassGetter;\n          value = new AST_Accessor(value);\n          break;\n\n        case \"set\":\n          ctor = AST_ClassSetter;\n          value = new AST_Accessor(value);\n          break;\n      }\n\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        private: internal,\n        static: M.static,\n        value: value\n      });\n    },\n    PropertyDefinition: function (M) {\n      var key = M.key,\n          internal = false;\n\n      if (M.computed) {\n        key = from_moz(key);\n      } else if (key.type == \"PrivateIdentifier\") {\n        internal = true;\n        key = \"#\" + key.name;\n      } else {\n        key = read_name(key);\n      }\n\n      return new AST_ClassField({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        private: internal,\n        static: M.static,\n        value: from_moz(M.value)\n      });\n    },\n    ForOfStatement: function (M) {\n      return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        init: from_moz(M.left),\n        object: from_moz(M.right),\n        body: from_moz(M.body)\n      });\n    },\n    TryStatement: function (M) {\n      var handlers = M.handlers || [M.handler];\n\n      if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n        throw new Error(\"Multiple catch clauses are not supported.\");\n      }\n\n      return new AST_Try({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.block).body,\n        bcatch: from_moz(handlers[0]),\n        bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n      });\n    },\n    Property: function (M) {\n      var key = M.computed ? from_moz(M.key) : read_name(M.key);\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        value: from_moz(M.value)\n      };\n      if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n      args.value = new AST_Accessor(args.value);\n      if (M.kind == \"get\") return new AST_ObjectGetter(args);\n      if (M.kind == \"set\") return new AST_ObjectSetter(args);\n    },\n    ArrayExpression: function (M) {\n      return new AST_Array({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: M.elements.map(function (elem) {\n          return elem === null ? new AST_Hole() : from_moz(elem);\n        })\n      });\n    },\n    ArrayPattern: function (M) {\n      var elements = [],\n          rest = null;\n      M.elements.forEach(function (el) {\n        if (el === null) {\n          elements.push(new AST_Hole());\n        } else if (el.type == \"RestElement\") {\n          rest = from_moz(el.argument);\n        } else {\n          elements.push(from_moz(el));\n        }\n      });\n      return new AST_DestructuredArray({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: elements,\n        rest: rest\n      });\n    },\n    ObjectPattern: function (M) {\n      var props = [],\n          rest = null;\n      M.properties.forEach(function (prop) {\n        if (prop.type == \"RestElement\") {\n          rest = from_moz(prop.argument);\n        } else {\n          props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n        }\n      });\n      return new AST_DestructuredObject({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: props,\n        rest: rest\n      });\n    },\n    MemberExpression: function (M) {\n      return new (M.computed ? AST_Sub : AST_Dot)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        optional: M.optional,\n        expression: from_moz(M.object),\n        property: M.computed ? from_moz(M.property) : M.property.name\n      });\n    },\n    MetaProperty: function (M) {\n      var expr = from_moz(M.meta);\n      var prop = read_name(M.property);\n      if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"new.target\"\n      });\n      return new AST_Dot({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: expr,\n        property: prop\n      });\n    },\n    SwitchCase: function (M) {\n      return new (M.test ? AST_Case : AST_Default)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.test),\n        body: M.consequent.map(from_moz)\n      });\n    },\n    ExportAllDeclaration: function (M) {\n      var alias = M.exported ? read_name(M.exported) : \"*\";\n      return new AST_ExportForeign({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        aliases: [alias],\n        keys: [\"*\"],\n        path: M.source.value\n      });\n    },\n    ExportDefaultDeclaration: function (M) {\n      var decl = from_moz(M.declaration);\n      if (!decl.name) switch (decl.CTOR) {\n        case AST_AsyncDefun:\n          decl = new AST_AsyncFunction(decl);\n          break;\n\n        case AST_AsyncGeneratorDefun:\n          decl = new AST_AsyncGeneratorFunction(decl);\n          break;\n\n        case AST_DefClass:\n          decl = new AST_ClassExpression(decl);\n          break;\n\n        case AST_Defun:\n          decl = new AST_Function(decl);\n          break;\n\n        case AST_GeneratorDefun:\n          decl = new AST_GeneratorFunction(decl);\n          break;\n      }\n      return new AST_ExportDefault({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: decl\n      });\n    },\n    ExportNamedDeclaration: function (M) {\n      if (M.declaration) return new AST_ExportDeclaration({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.declaration)\n      });\n\n      if (M.source) {\n        var aliases = [],\n            keys = [];\n        M.specifiers.forEach(function (prop) {\n          aliases.push(read_name(prop.exported));\n          keys.push(read_name(prop.local));\n        });\n        return new AST_ExportForeign({\n          start: my_start_token(M),\n          end: my_end_token(M),\n          aliases: aliases,\n          keys: keys,\n          path: M.source.value\n        });\n      }\n\n      return new AST_ExportReferences({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: M.specifiers.map(function (prop) {\n          var sym = new AST_SymbolExport(from_moz(prop.local));\n          sym.alias = read_name(prop.exported);\n          return sym;\n        })\n      });\n    },\n    ImportDeclaration: function (M) {\n      var all = null,\n          def = null,\n          props = null;\n      M.specifiers.forEach(function (prop) {\n        var sym = new AST_SymbolImport(from_moz(prop.local));\n\n        switch (prop.type) {\n          case \"ImportDefaultSpecifier\":\n            def = sym;\n            def.key = \"\";\n            break;\n\n          case \"ImportNamespaceSpecifier\":\n            all = sym;\n            all.key = \"*\";\n            break;\n\n          default:\n            sym.key = prop.imported.name || syn.name;\n            if (!props) props = [];\n            props.push(sym);\n            break;\n        }\n      });\n      return new AST_Import({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        all: all,\n        default: def,\n        properties: props,\n        path: M.source.value\n      });\n    },\n    ImportExpression: function (M) {\n      var start = my_start_token(M);\n      var arg = from_moz(M.source);\n      return new AST_Call({\n        start: start,\n        end: my_end_token(M),\n        expression: new AST_SymbolRef({\n          start: start,\n          end: arg.start,\n          name: \"import\"\n        }),\n        args: [arg]\n      });\n    },\n    VariableDeclaration: function (M) {\n      return new ({\n        const: AST_Const,\n        let: AST_Let\n      }[M.kind] || AST_Var)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        definitions: M.declarations.map(from_moz)\n      });\n    },\n    Literal: function (M) {\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M)\n      };\n\n      if (M.bigint) {\n        args.value = M.bigint.toLowerCase() + \"n\";\n        return new AST_BigInt(args);\n      }\n\n      var val = M.value;\n      if (val === null) return new AST_Null(args);\n      var rx = M.regex;\n\n      if (rx && rx.pattern) {\n        // RegExpLiteral as per ESTree AST spec\n        args.value = new RegExp(rx.pattern, rx.flags);\n        args.value.raw_source = rx.pattern;\n        return new AST_RegExp(args);\n      } else if (rx) {\n        // support legacy RegExp\n        args.value = M.regex && M.raw ? M.raw : val;\n        return new AST_RegExp(args);\n      }\n\n      switch (typeof val) {\n        case \"string\":\n          args.value = val;\n          return new AST_String(args);\n\n        case \"number\":\n          if (isNaN(val)) return new AST_NaN(args);\n          var negate, node;\n\n          if (isFinite(val)) {\n            negate = 1 / val < 0;\n            args.value = negate ? -val : val;\n            node = new AST_Number(args);\n          } else {\n            negate = val < 0;\n            node = new AST_Infinity(args);\n          }\n\n          return negate ? new AST_UnaryPrefix({\n            start: args.start,\n            end: args.end,\n            operator: \"-\",\n            expression: node\n          }) : node;\n\n        case \"boolean\":\n          return new (val ? AST_True : AST_False)(args);\n      }\n    },\n    TemplateLiteral: function (M) {\n      return new AST_Template({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expressions: M.expressions.map(from_moz),\n        strings: M.quasis.map(function (el) {\n          return el.value.raw;\n        })\n      });\n    },\n    TaggedTemplateExpression: function (M) {\n      var tmpl = from_moz(M.quasi);\n      tmpl.start = my_start_token(M);\n      tmpl.end = my_end_token(M);\n      tmpl.tag = from_moz(M.tag);\n      return tmpl;\n    },\n    Identifier: function (M) {\n      var p,\n          level = FROM_MOZ_STACK.length - 1;\n\n      do {\n        p = FROM_MOZ_STACK[--level];\n      } while (p.type == \"ArrayPattern\" || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1] || p.type == \"ObjectPattern\" || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1] || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n\n      var ctor = AST_SymbolRef;\n\n      switch (p.type) {\n        case \"ArrowFunctionExpression\":\n          if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n          break;\n\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n          ctor = AST_LabelRef;\n          break;\n\n        case \"CatchClause\":\n          ctor = AST_SymbolCatch;\n          break;\n\n        case \"ClassDeclaration\":\n          if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n          break;\n\n        case \"ClassExpression\":\n          if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n          break;\n\n        case \"FunctionDeclaration\":\n          ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n          break;\n\n        case \"FunctionExpression\":\n          ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n          break;\n\n        case \"LabeledStatement\":\n          ctor = AST_Label;\n          break;\n\n        case \"VariableDeclaration\":\n          ctor = {\n            const: AST_SymbolConst,\n            let: AST_SymbolLet\n          }[p.kind] || AST_SymbolVar;\n          break;\n      }\n\n      return new ctor({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: M.name\n      });\n    },\n    Super: function (M) {\n      return new AST_Super({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"super\"\n      });\n    },\n    ThisExpression: function (M) {\n      return new AST_This({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: \"this\"\n      });\n    },\n    ParenthesizedExpression: function (M) {\n      var node = from_moz(M.expression);\n      if (!node.start.parens) node.start.parens = [];\n      node.start.parens.push(my_start_token(M));\n      if (!node.end.parens) node.end.parens = [];\n      node.end.parens.push(my_end_token(M));\n      return node;\n    },\n    ChainExpression: function (M) {\n      var node = from_moz(M.expression);\n      node.terminal = true;\n      return node;\n    }\n  };\n\n  MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n    var prefix = \"prefix\" in M ? M.prefix : M.type == \"UnaryExpression\" ? true : false;\n    return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      operator: M.operator,\n      expression: from_moz(M.argument)\n    });\n  };\n\n  map(\"EmptyStatement\", AST_EmptyStatement);\n  map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n  map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n  map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n  map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n  map(\"BreakStatement\", AST_Break, \"label>label\");\n  map(\"ContinueStatement\", AST_Continue, \"label>label\");\n  map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n  map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n  map(\"ReturnStatement\", AST_Return, \"argument>value\");\n  map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n  map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n  map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n  map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n  map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n  map(\"DebuggerStatement\", AST_Debugger);\n  map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n  map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n  map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n  map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n  map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n  map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n  map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n  map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n  map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n  map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n  map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n  map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n  def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n    return to_moz_scope(\"Program\", M);\n  });\n  def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n    var params = M.argnames.map(to_moz);\n    if (M.rest) params.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"FunctionDeclaration\",\n      id: to_moz(M.name),\n      async: is_async(M),\n      generator: is_generator(M),\n      params: params,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n    var params = M.argnames.map(to_moz);\n    if (M.rest) params.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    if (is_arrow(M)) return {\n      type: \"ArrowFunctionExpression\",\n      async: is_async(M),\n      params: params,\n      body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M)\n    };\n    return {\n      type: \"FunctionExpression\",\n      id: to_moz(M.name),\n      async: is_async(M),\n      generator: is_generator(M),\n      params: params,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n    return {\n      type: \"ClassDeclaration\",\n      id: to_moz(M.name),\n      superClass: to_moz(M.extends),\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n  def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n    return {\n      type: \"ClassExpression\",\n      id: to_moz(M.name),\n      superClass: to_moz(M.extends),\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n\n  function To_Moz_MethodDefinition(kind) {\n    return function (M) {\n      var computed = M.key instanceof AST_Node;\n      var key = computed ? to_moz(M.key) : M.private ? {\n        type: \"PrivateIdentifier\",\n        name: M.key.slice(1)\n      } : {\n        type: \"Literal\",\n        value: M.key\n      };\n      return {\n        type: \"MethodDefinition\",\n        kind: kind,\n        computed: computed,\n        key: key,\n        static: M.static,\n        value: to_moz(M.value)\n      };\n    };\n  }\n\n  def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n  def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n  def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n  def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : M.private ? {\n      type: \"PrivateIdentifier\",\n      name: M.key.slice(1)\n    } : {\n      type: \"Literal\",\n      value: M.key\n    };\n    return {\n      type: \"PropertyDefinition\",\n      computed: computed,\n      key: key,\n      static: M.static,\n      value: to_moz(M.value)\n    };\n  });\n\n  function To_Moz_ForOfStatement(is_await) {\n    return function (M) {\n      return {\n        type: \"ForOfStatement\",\n        await: is_await,\n        left: to_moz(M.init),\n        right: to_moz(M.object),\n        body: to_moz(M.body)\n      };\n    };\n  }\n\n  def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n  def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n  def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n    return {\n      type: \"ExpressionStatement\",\n      expression: set_moz_loc(M, {\n        type: \"Literal\",\n        value: M.value\n      })\n    };\n  });\n  def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n    return {\n      type: \"SwitchCase\",\n      test: to_moz(M.expression),\n      consequent: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n    return {\n      type: \"TryStatement\",\n      block: to_moz_block(M),\n      handler: to_moz(M.bcatch),\n      guardedHandlers: [],\n      finalizer: to_moz(M.bfinally)\n    };\n  });\n  def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n    return {\n      type: \"CatchClause\",\n      param: to_moz(M.argname),\n      guard: null,\n      body: to_moz_block(M)\n    };\n  });\n  def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n    return {\n      type: \"ExportNamedDeclaration\",\n      declaration: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n    return {\n      type: \"ExportDefaultDeclaration\",\n      declaration: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n    if (M.keys[0] == \"*\") return {\n      type: \"ExportAllDeclaration\",\n      exported: M.aliases[0] == \"*\" ? null : {\n        type: \"Identifier\",\n        name: M.aliases[0]\n      },\n      source: {\n        type: \"Literal\",\n        value: M.path\n      }\n    };\n    var specifiers = [];\n\n    for (var i = 0; i < M.aliases.length; i++) {\n      specifiers.push({\n        type: \"ExportSpecifier\",\n        exported: {\n          type: \"Identifier\",\n          name: M.aliases[i]\n        },\n        local: {\n          type: \"Identifier\",\n          name: M.keys[i]\n        }\n      });\n    }\n\n    return {\n      type: \"ExportNamedDeclaration\",\n      specifiers: specifiers,\n      source: {\n        type: \"Literal\",\n        value: M.path\n      }\n    };\n  });\n  def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n    return {\n      type: \"ExportNamedDeclaration\",\n      specifiers: M.properties.map(function (prop) {\n        return {\n          type: \"ExportSpecifier\",\n          local: to_moz(prop),\n          exported: {\n            type: \"Identifier\",\n            name: prop.alias\n          }\n        };\n      })\n    };\n  });\n  def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n    var specifiers = M.properties ? M.properties.map(function (prop) {\n      return {\n        type: \"ImportSpecifier\",\n        local: to_moz(prop),\n        imported: {\n          type: \"Identifier\",\n          name: prop.key\n        }\n      };\n    }) : [];\n    if (M.all) specifiers.unshift({\n      type: \"ImportNamespaceSpecifier\",\n      local: to_moz(M.all)\n    });\n    if (M.default) specifiers.unshift({\n      type: \"ImportDefaultSpecifier\",\n      local: to_moz(M.default)\n    });\n    return {\n      type: \"ImportDeclaration\",\n      specifiers: specifiers,\n      source: {\n        type: \"Literal\",\n        value: M.path\n      }\n    };\n  });\n  def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n    return {\n      type: \"VariableDeclaration\",\n      kind: M.TYPE.toLowerCase(),\n      declarations: M.definitions.map(to_moz)\n    };\n  });\n  def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n    var computed = M instanceof AST_Sub;\n    var expr = {\n      type: \"MemberExpression\",\n      object: to_moz(M.expression),\n      computed: computed,\n      optional: M.optional,\n      property: computed ? to_moz(M.property) : {\n        type: \"Identifier\",\n        name: M.property\n      }\n    };\n    return M.terminal ? {\n      type: \"ChainExpression\",\n      expression: expr\n    } : expr;\n  });\n  def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n    return {\n      type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n      operator: M.operator,\n      prefix: M instanceof AST_UnaryPrefix,\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n    return {\n      type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n      left: to_moz(M.left),\n      operator: M.operator,\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n    return {\n      type: \"ArrayExpression\",\n      elements: M.elements.map(to_moz)\n    };\n  });\n  def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n    var elements = M.elements.map(to_moz);\n    if (M.rest) elements.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"ArrayPattern\",\n      elements: elements\n    };\n  });\n  def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : {\n      type: \"Literal\",\n      value: M.key\n    };\n    return {\n      type: \"Property\",\n      kind: \"init\",\n      computed: computed,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n    var props = M.properties.map(to_moz);\n    if (M.rest) props.push({\n      type: \"RestElement\",\n      argument: to_moz(M.rest)\n    });\n    return {\n      type: \"ObjectPattern\",\n      properties: props\n    };\n  });\n  def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n    var computed = M.key instanceof AST_Node;\n    var key = computed ? to_moz(M.key) : {\n      type: \"Literal\",\n      value: M.key\n    };\n    var kind;\n\n    if (M instanceof AST_ObjectKeyVal) {\n      kind = \"init\";\n    } else if (M instanceof AST_ObjectGetter) {\n      kind = \"get\";\n    } else if (M instanceof AST_ObjectSetter) {\n      kind = \"set\";\n    }\n\n    return {\n      type: \"Property\",\n      kind: kind,\n      computed: computed,\n      method: M instanceof AST_ObjectMethod,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n    var def = M.definition();\n    return {\n      type: \"Identifier\",\n      name: def && def.mangled_name || M.name\n    };\n  });\n  def_to_moz(AST_Super, function To_Moz_Super() {\n    return {\n      type: \"Super\"\n    };\n  });\n  def_to_moz(AST_This, function To_Moz_ThisExpression() {\n    return {\n      type: \"ThisExpression\"\n    };\n  });\n  def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"new\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"target\"\n      }\n    };\n  });\n  def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n    var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n    var value = \"/\" + M.value.raw_source + \"/\" + flags;\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: value,\n      regex: {\n        pattern: M.value.raw_source,\n        flags: flags\n      }\n    };\n  });\n  def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n    var value = M.value;\n    return {\n      type: \"Literal\",\n      bigint: value.slice(0, -1),\n      raw: value\n    };\n  });\n\n  function To_Moz_Literal(M) {\n    var value = M.value;\n\n    if (typeof value === \"number\" && (value < 0 || value === 0 && 1 / value < 0)) {\n      return {\n        type: \"UnaryExpression\",\n        operator: \"-\",\n        prefix: true,\n        argument: {\n          type: \"Literal\",\n          value: -value,\n          raw: M.start.raw\n        }\n      };\n    }\n\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: M.start.raw\n    };\n  }\n\n  def_to_moz(AST_Boolean, To_Moz_Literal);\n  def_to_moz(AST_Constant, To_Moz_Literal);\n  def_to_moz(AST_Null, To_Moz_Literal);\n  def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n    return {\n      type: \"Identifier\",\n      name: String(M.value)\n    };\n  });\n  def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n    var last = M.strings.length - 1;\n    var tmpl = {\n      type: \"TemplateLiteral\",\n      expressions: M.expressions.map(to_moz),\n      quasis: M.strings.map(function (str, index) {\n        return {\n          type: \"TemplateElement\",\n          tail: index == last,\n          value: {\n            raw: str\n          }\n        };\n      })\n    };\n    if (!M.tag) return tmpl;\n    return {\n      type: \"TaggedTemplateExpression\",\n      tag: to_moz(M.tag),\n      quasi: tmpl\n    };\n  });\n  AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n  AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n  AST_Node.DEFMETHOD(\"to_mozilla_ast\", function () {\n    throw new Error(\"Cannot convert AST_\" + this.TYPE);\n  });\n  /* -----[ tools ]----- */\n\n  function normalize_directives(body) {\n    for (var i = 0; i < body.length; i++) {\n      var stat = body[i];\n      if (!(stat instanceof AST_SimpleStatement)) break;\n      var node = stat.body;\n      if (!(node instanceof AST_String)) break;\n      if (stat.start.pos !== node.start.pos) break;\n      body[i] = new AST_Directive(node);\n    }\n\n    return body;\n  }\n\n  function raw_token(moznode) {\n    if (moznode.type == \"Literal\") {\n      return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n    }\n  }\n\n  function my_start_token(moznode) {\n    var loc = moznode.loc,\n        start = loc && loc.start;\n    var range = moznode.range;\n    return new AST_Token({\n      file: loc && loc.source,\n      line: start && start.line,\n      col: start && start.column,\n      pos: range ? range[0] : moznode.start,\n      endline: start && start.line,\n      endcol: start && start.column,\n      endpos: range ? range[0] : moznode.start,\n      raw: raw_token(moznode)\n    });\n  }\n\n  function my_end_token(moznode) {\n    var loc = moznode.loc,\n        end = loc && loc.end;\n    var range = moznode.range;\n    return new AST_Token({\n      file: loc && loc.source,\n      line: end && end.line,\n      col: end && end.column,\n      pos: range ? range[1] : moznode.end,\n      endline: end && end.line,\n      endcol: end && end.column,\n      endpos: range ? range[1] : moznode.end,\n      raw: raw_token(moznode)\n    });\n  }\n\n  function read_name(M) {\n    return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n  }\n\n  function map(moztype, mytype, propmap) {\n    var moz_to_me = [\"start: my_start_token(M)\", \"end: my_end_token(M)\"];\n    var me_to_moz = [\"type: \" + JSON.stringify(moztype)];\n    if (propmap) propmap.split(/\\s*,\\s*/).forEach(function (prop) {\n      var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n      if (!m) throw new Error(\"Can't understand property map: \" + prop);\n      var moz = m[1],\n          how = m[2],\n          my = m[3];\n\n      switch (how) {\n        case \"@\":\n          moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n          me_to_moz.push(moz + \": M.\" + my + \".map(to_moz)\");\n          break;\n\n        case \">\":\n          moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n          me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n          break;\n\n        case \"=\":\n          moz_to_me.push(my + \": M.\" + moz);\n          me_to_moz.push(moz + \": M.\" + my);\n          break;\n\n        case \"%\":\n          moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n          me_to_moz.push(moz + \": to_moz_block(M)\");\n          break;\n\n        default:\n          throw new Error(\"Can't understand operator in propmap: \" + prop);\n      }\n    });\n    MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\"return function From_Moz_\" + moztype + \"(M) {\", \"    return new U2.AST_\" + mytype.TYPE + \"({\", moz_to_me.join(\",\\n\"), \"    });\", \"};\"].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n    def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\"return function To_Moz_\" + moztype + \"(M) {\", \"    return {\", me_to_moz.join(\",\\n\"), \"    };\", \"};\"].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n  }\n\n  var FROM_MOZ_STACK = null;\n\n  function from_moz(moz) {\n    FROM_MOZ_STACK.push(moz);\n    var node = null;\n\n    if (moz) {\n      if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n      node = MOZ_TO_ME[moz.type](moz);\n    }\n\n    FROM_MOZ_STACK.pop();\n    return node;\n  }\n\n  AST_Node.from_mozilla_ast = function (node) {\n    var save_stack = FROM_MOZ_STACK;\n    FROM_MOZ_STACK = [];\n    var ast = from_moz(node);\n    FROM_MOZ_STACK = save_stack;\n    ast.walk(new TreeWalker(function (node) {\n      if (node instanceof AST_LabelRef) {\n        for (var level = 0, parent; parent = this.parent(level); level++) {\n          if (parent instanceof AST_Scope) break;\n\n          if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n            node.thedef = parent.label;\n            break;\n          }\n        }\n\n        if (!node.thedef) {\n          var s = node.start;\n          js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n        }\n      }\n    }));\n    return ast;\n  };\n\n  function set_moz_loc(mynode, moznode) {\n    var start = mynode.start;\n    var end = mynode.end;\n\n    if (start.pos != null && end.endpos != null) {\n      moznode.range = [start.pos, end.endpos];\n    }\n\n    if (start.line) {\n      moznode.loc = {\n        start: {\n          line: start.line,\n          column: start.col\n        },\n        end: end.endline ? {\n          line: end.endline,\n          column: end.endcol\n        } : null\n      };\n\n      if (start.file) {\n        moznode.loc.source = start.file;\n      }\n    }\n\n    return moznode;\n  }\n\n  function def_to_moz(mytype, handler) {\n    mytype.DEFMETHOD(\"to_mozilla_ast\", function () {\n      return set_moz_loc(this, handler(this));\n    });\n  }\n\n  function to_moz(node) {\n    return node != null ? node.to_mozilla_ast() : null;\n  }\n\n  function to_moz_block(node) {\n    return {\n      type: \"BlockStatement\",\n      body: node.body.map(to_moz)\n    };\n  }\n\n  function to_moz_scope(type, node) {\n    var body = node.body.map(to_moz);\n\n    if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n      body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n    }\n\n    return {\n      type: type,\n      body: body\n    };\n  }\n})();","map":{"version":3,"sources":["/home/harsha/Desktop/ug2 spring SEM2/DAss/mongo/frontend/node_modules/uglify-js/lib/mozilla-ast.js"],"names":["MOZ_TO_ME","Program","M","AST_Toplevel","start","my_start_token","end","my_end_token","body","normalize_directives","map","from_moz","ArrowFunctionExpression","argnames","rest","params","forEach","param","type","argument","push","fn","async","AST_AsyncArrow","AST_Arrow","node","AST_BlockStatement","value","FunctionDeclaration","ctor","generator","AST_AsyncGeneratorDefun","AST_AsyncDefun","AST_GeneratorDefun","AST_Defun","name","id","FunctionExpression","AST_AsyncGeneratorFunction","AST_AsyncFunction","AST_GeneratorFunction","AST_Function","ClassDeclaration","AST_DefClass","extends","superClass","properties","ClassExpression","AST_ClassExpression","MethodDefinition","key","internal","computed","read_name","AST_ClassMethod","kind","AST_ClassGetter","AST_Accessor","AST_ClassSetter","private","static","PropertyDefinition","AST_ClassField","ForOfStatement","await","AST_ForAwaitOf","AST_ForOf","init","left","object","right","TryStatement","handlers","handler","length","guardedHandlers","Error","AST_Try","block","bcatch","bfinally","finalizer","AST_Finally","Property","args","method","AST_ObjectMethod","AST_ObjectKeyVal","AST_ObjectGetter","AST_ObjectSetter","ArrayExpression","AST_Array","elements","elem","AST_Hole","ArrayPattern","el","AST_DestructuredArray","ObjectPattern","props","prop","AST_DestructuredKeyVal","AST_DestructuredObject","MemberExpression","AST_Sub","AST_Dot","optional","expression","property","MetaProperty","expr","meta","AST_NewTarget","SwitchCase","test","AST_Case","AST_Default","consequent","ExportAllDeclaration","alias","exported","AST_ExportForeign","aliases","keys","path","source","ExportDefaultDeclaration","decl","declaration","CTOR","AST_ExportDefault","ExportNamedDeclaration","AST_ExportDeclaration","specifiers","local","AST_ExportReferences","sym","AST_SymbolExport","ImportDeclaration","all","def","AST_SymbolImport","imported","syn","AST_Import","default","ImportExpression","arg","AST_Call","AST_SymbolRef","VariableDeclaration","const","AST_Const","let","AST_Let","AST_Var","definitions","declarations","Literal","bigint","toLowerCase","AST_BigInt","val","AST_Null","rx","regex","pattern","RegExp","flags","raw_source","AST_RegExp","raw","AST_String","isNaN","AST_NaN","negate","isFinite","AST_Number","AST_Infinity","AST_UnaryPrefix","operator","AST_True","AST_False","TemplateLiteral","AST_Template","expressions","strings","quasis","TaggedTemplateExpression","tmpl","quasi","tag","Identifier","p","level","FROM_MOZ_STACK","AST_SymbolFunarg","AST_LabelRef","AST_SymbolCatch","AST_SymbolDefClass","AST_SymbolClass","AST_SymbolDefun","AST_SymbolLambda","AST_Label","AST_SymbolConst","AST_SymbolLet","AST_SymbolVar","Super","AST_Super","ThisExpression","AST_This","ParenthesizedExpression","parens","ChainExpression","terminal","UpdateExpression","UnaryExpression","To_Moz_Unary","prefix","AST_UnaryPostfix","AST_EmptyStatement","AST_SimpleStatement","AST_If","AST_LabeledStatement","AST_Break","AST_Continue","AST_With","AST_Switch","AST_Return","AST_Throw","AST_While","AST_Do","AST_For","AST_ForIn","AST_Debugger","AST_VarDef","AST_Catch","AST_Binary","AST_Assign","AST_DefaultValue","AST_Conditional","AST_New","AST_Sequence","AST_Spread","AST_Object","AST_Await","AST_Yield","def_to_moz","To_Moz_Program","to_moz_scope","AST_LambdaDefinition","To_Moz_FunctionDeclaration","to_moz","is_async","is_generator","AST_Lambda","To_Moz_FunctionExpression","is_arrow","To_Moz_ClassDeclaration","To_Moz_ClassExpression","To_Moz_MethodDefinition","AST_Node","slice","To_Moz_PropertyDefinition","To_Moz_ForOfStatement","is_await","AST_Directive","To_Moz_Directive","set_moz_loc","AST_SwitchBranch","To_Moz_SwitchCase","To_Moz_TryStatement","to_moz_block","To_Moz_CatchClause","argname","guard","To_Moz_ExportNamedDeclaration_declaration","To_Moz_ExportDefaultDeclaration","To_Moz_ExportAllDeclaration_ExportNamedDeclaration","i","To_Moz_ExportNamedDeclaration_specifiers","To_Moz_ImportDeclaration","unshift","AST_Definitions","To_Moz_VariableDeclaration","TYPE","AST_PropAccess","To_Moz_MemberExpression","AST_Unary","To_Moz_BinaryExpression","To_Moz_ArrayExpression","To_Moz_ArrayPattern","To_Moz_Property","To_Moz_ObjectPattern","AST_ObjectProperty","AST_Symbol","To_Moz_Identifier","definition","mangled_name","To_Moz_Super","To_Moz_ThisExpression","To_Moz_MetaProperty","To_Moz_RegExpLiteral","toString","match","To_Moz_BigInt","To_Moz_Literal","AST_Boolean","AST_Constant","AST_Atom","To_Moz_Atom","String","To_Moz_TemplateLiteral_TaggedTemplateExpression","last","str","index","tail","AST_Block","DEFMETHOD","prototype","to_mozilla_ast","return_null","stat","pos","raw_token","moznode","loc","range","AST_Token","file","line","col","column","endline","endcol","endpos","moztype","mytype","propmap","moz_to_me","me_to_moz","JSON","stringify","split","m","exec","moz","how","my","Function","join","exports","HOP","pop","from_mozilla_ast","save_stack","ast","walk","TreeWalker","parent","AST_Scope","label","thedef","s","js_error","mynode"],"mappings":"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","sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\n\"use strict\";\n\n(function() {\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz)),\n            });\n        },\n        ArrowFunctionExpression: function(M) {\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            var fn = new (M.async ? AST_AsyncArrow : AST_Arrow)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argnames: argnames,\n                rest: rest,\n            });\n            var node = from_moz(M.body);\n            if (node instanceof AST_BlockStatement) {\n                fn.body = normalize_directives(node.body);\n                fn.value = null;\n            } else {\n                fn.body = [];\n                fn.value = node;\n            }\n            return fn;\n        },\n        FunctionDeclaration: function(M) {\n            var ctor;\n            if (M.async) {\n                ctor = M.generator ? AST_AsyncGeneratorDefun : AST_AsyncDefun;\n            } else {\n                ctor = M.generator ? AST_GeneratorDefun : AST_Defun;\n            }\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: argnames,\n                rest: rest,\n                body: normalize_directives(from_moz(M.body).body),\n            });\n        },\n        FunctionExpression: function(M) {\n            var ctor;\n            if (M.async) {\n                ctor = M.generator ? AST_AsyncGeneratorFunction : AST_AsyncFunction;\n            } else {\n                ctor = M.generator ? AST_GeneratorFunction : AST_Function;\n            }\n            var argnames = [], rest = null;\n            M.params.forEach(function(param) {\n                if (param.type == \"RestElement\") {\n                    rest = from_moz(param.argument);\n                } else {\n                    argnames.push(from_moz(param));\n                }\n            });\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: argnames,\n                rest: rest,\n                body: normalize_directives(from_moz(M.body).body),\n            });\n        },\n        ClassDeclaration: function(M) {\n            return new AST_DefClass({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                extends: from_moz(M.superClass),\n                properties: M.body.body.map(from_moz),\n            });\n        },\n        ClassExpression: function(M) {\n            return new AST_ClassExpression({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                extends: from_moz(M.superClass),\n                properties: M.body.body.map(from_moz),\n            });\n        },\n        MethodDefinition: function(M) {\n            var key = M.key, internal = false;\n            if (M.computed) {\n                key = from_moz(key);\n            } else if (key.type == \"PrivateIdentifier\") {\n                internal = true;\n                key = \"#\" + key.name;\n            } else {\n                key = read_name(key);\n            }\n            var ctor = AST_ClassMethod, value = from_moz(M.value);\n            switch (M.kind) {\n              case \"get\":\n                ctor = AST_ClassGetter;\n                value = new AST_Accessor(value);\n                break;\n              case \"set\":\n                ctor = AST_ClassSetter;\n                value = new AST_Accessor(value);\n                break;\n            }\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                private: internal,\n                static: M.static,\n                value: value,\n            });\n        },\n        PropertyDefinition: function(M) {\n            var key = M.key, internal = false;\n            if (M.computed) {\n                key = from_moz(key);\n            } else if (key.type == \"PrivateIdentifier\") {\n                internal = true;\n                key = \"#\" + key.name;\n            } else {\n                key = read_name(key);\n            }\n            return new AST_ClassField({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                private: internal,\n                static: M.static,\n                value: from_moz(M.value),\n            });\n        },\n        ForOfStatement: function(M) {\n            return new (M.await ? AST_ForAwaitOf : AST_ForOf)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                init: from_moz(M.left),\n                object: from_moz(M.right),\n                body: from_moz(M.body),\n            });\n        },\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : from_moz(M.block).body,\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null,\n            });\n        },\n        Property: function(M) {\n            var key = M.computed ? from_moz(M.key) : read_name(M.key);\n            var args = {\n                start: my_start_token(M),\n                end: my_end_token(M),\n                key: key,\n                value: from_moz(M.value),\n            };\n            if (M.kind == \"init\") return new (M.method ? AST_ObjectMethod : AST_ObjectKeyVal)(args);\n            args.value = new AST_Accessor(args.value);\n            if (M.kind == \"get\") return new AST_ObjectGetter(args);\n            if (M.kind == \"set\") return new AST_ObjectSetter(args);\n        },\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                elements: M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                }),\n            });\n        },\n        ArrayPattern: function(M) {\n            var elements = [], rest = null;\n            M.elements.forEach(function(el) {\n                if (el === null) {\n                    elements.push(new AST_Hole());\n                } else if (el.type == \"RestElement\") {\n                    rest = from_moz(el.argument);\n                } else {\n                    elements.push(from_moz(el));\n                }\n            });\n            return new AST_DestructuredArray({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                elements: elements,\n                rest: rest,\n            });\n        },\n        ObjectPattern: function(M) {\n            var props = [], rest = null;\n            M.properties.forEach(function(prop) {\n                if (prop.type == \"RestElement\") {\n                    rest = from_moz(prop.argument);\n                } else {\n                    props.push(new AST_DestructuredKeyVal(from_moz(prop)));\n                }\n            });\n            return new AST_DestructuredObject({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                properties: props,\n                rest: rest,\n            });\n        },\n        MemberExpression: function(M) {\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                optional: M.optional,\n                expression: from_moz(M.object),\n                property: M.computed ? from_moz(M.property) : M.property.name,\n            });\n        },\n        MetaProperty: function(M) {\n            var expr = from_moz(M.meta);\n            var prop = read_name(M.property);\n            if (expr.name == \"new\" && prop == \"target\") return new AST_NewTarget({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"new.target\",\n            });\n            return new AST_Dot({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: expr,\n                property: prop,\n            });\n        },\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz),\n            });\n        },\n        ExportAllDeclaration: function(M) {\n            var alias = M.exported ? read_name(M.exported) : \"*\";\n            return new AST_ExportForeign({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                aliases: [ alias ],\n                keys: [ \"*\" ],\n                path: M.source.value,\n            });\n        },\n        ExportDefaultDeclaration: function(M) {\n            var decl = from_moz(M.declaration);\n            if (!decl.name) switch (decl.CTOR) {\n              case AST_AsyncDefun:\n                decl = new AST_AsyncFunction(decl);\n                break;\n              case AST_AsyncGeneratorDefun:\n                decl = new AST_AsyncGeneratorFunction(decl);\n                break;\n              case AST_DefClass:\n                decl = new AST_ClassExpression(decl);\n                break;\n              case AST_Defun:\n                decl = new AST_Function(decl);\n                break;\n              case AST_GeneratorDefun:\n                decl = new AST_GeneratorFunction(decl);\n                break;\n            }\n            return new AST_ExportDefault({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: decl,\n            });\n        },\n        ExportNamedDeclaration: function(M) {\n            if (M.declaration) return new AST_ExportDeclaration({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.declaration),\n            });\n            if (M.source) {\n                var aliases = [], keys = [];\n                M.specifiers.forEach(function(prop) {\n                    aliases.push(read_name(prop.exported));\n                    keys.push(read_name(prop.local));\n                });\n                return new AST_ExportForeign({\n                    start: my_start_token(M),\n                    end: my_end_token(M),\n                    aliases: aliases,\n                    keys: keys,\n                    path: M.source.value,\n                });\n            }\n            return new AST_ExportReferences({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                properties: M.specifiers.map(function(prop) {\n                    var sym = new AST_SymbolExport(from_moz(prop.local));\n                    sym.alias = read_name(prop.exported);\n                    return sym;\n                }),\n            });\n        },\n        ImportDeclaration: function(M) {\n            var all = null, def = null, props = null;\n            M.specifiers.forEach(function(prop) {\n                var sym = new AST_SymbolImport(from_moz(prop.local));\n                switch (prop.type) {\n                  case \"ImportDefaultSpecifier\":\n                    def = sym;\n                    def.key = \"\";\n                    break;\n                  case \"ImportNamespaceSpecifier\":\n                    all = sym;\n                    all.key = \"*\";\n                    break;\n                  default:\n                    sym.key = prop.imported.name || syn.name;\n                    if (!props) props = [];\n                    props.push(sym);\n                    break;\n                }\n            });\n            return new AST_Import({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                all: all,\n                default: def,\n                properties: props,\n                path: M.source.value,\n            });\n        },\n        ImportExpression: function(M) {\n            var start = my_start_token(M);\n            var arg = from_moz(M.source);\n            return new AST_Call({\n                start: start,\n                end: my_end_token(M),\n                expression: new AST_SymbolRef({\n                    start: start,\n                    end: arg.start,\n                    name: \"import\",\n                }),\n                args: [ arg ],\n            });\n        },\n        VariableDeclaration: function(M) {\n            return new ({\n                const: AST_Const,\n                let: AST_Let,\n            }[M.kind] || AST_Var)({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                definitions: M.declarations.map(from_moz),\n            });\n        },\n        Literal: function(M) {\n            var args = {\n                start: my_start_token(M),\n                end: my_end_token(M),\n            };\n            if (M.bigint) {\n                args.value = M.bigint.toLowerCase() + \"n\";\n                return new AST_BigInt(args);\n            }\n            var val = M.value;\n            if (val === null) return new AST_Null(args);\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = new RegExp(rx.pattern, rx.flags);\n                args.value.raw_source = rx.pattern;\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                args.value = M.regex && M.raw ? M.raw : val;\n                return new AST_RegExp(args);\n            }\n            switch (typeof val) {\n              case \"string\":\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                if (isNaN(val)) return new AST_NaN(args);\n                var negate, node;\n                if (isFinite(val)) {\n                    negate = 1 / val < 0;\n                    args.value = negate ? -val : val;\n                    node = new AST_Number(args);\n                } else {\n                    negate = val < 0;\n                    node = new AST_Infinity(args);\n                }\n                return negate ? new AST_UnaryPrefix({\n                    start: args.start,\n                    end: args.end,\n                    operator: \"-\",\n                    expression: node,\n                }) : node;\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n        TemplateLiteral: function(M) {\n            return new AST_Template({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expressions: M.expressions.map(from_moz),\n                strings: M.quasis.map(function(el) {\n                    return el.value.raw;\n                }),\n            });\n        },\n        TaggedTemplateExpression: function(M) {\n            var tmpl = from_moz(M.quasi);\n            tmpl.start = my_start_token(M);\n            tmpl.end = my_end_token(M);\n            tmpl.tag = from_moz(M.tag);\n            return tmpl;\n        },\n        Identifier: function(M) {\n            var p, level = FROM_MOZ_STACK.length - 1;\n            do {\n                p = FROM_MOZ_STACK[--level];\n            } while (p.type == \"ArrayPattern\"\n                || p.type == \"AssignmentPattern\" && p.left === FROM_MOZ_STACK[level + 1]\n                || p.type == \"ObjectPattern\"\n                || p.type == \"Property\" && p.value === FROM_MOZ_STACK[level + 1]\n                || p.type == \"VariableDeclarator\" && p.id === FROM_MOZ_STACK[level + 1]);\n            var ctor = AST_SymbolRef;\n            switch (p.type) {\n              case \"ArrowFunctionExpression\":\n                if (p.body !== FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolFunarg;\n                break;\n              case \"BreakStatement\":\n              case \"ContinueStatement\":\n                ctor = AST_LabelRef;\n                break;\n              case \"CatchClause\":\n                ctor = AST_SymbolCatch;\n                break;\n              case \"ClassDeclaration\":\n                if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolDefClass;\n                break;\n              case \"ClassExpression\":\n                if (p.id === FROM_MOZ_STACK[level + 1]) ctor = AST_SymbolClass;\n                break;\n              case \"FunctionDeclaration\":\n                ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolDefun : AST_SymbolFunarg;\n                break;\n              case \"FunctionExpression\":\n                ctor = p.id === FROM_MOZ_STACK[level + 1] ? AST_SymbolLambda : AST_SymbolFunarg;\n                break;\n              case \"LabeledStatement\":\n                ctor = AST_Label;\n                break;\n              case \"VariableDeclaration\":\n                ctor = {\n                    const: AST_SymbolConst,\n                    let: AST_SymbolLet,\n                }[p.kind] || AST_SymbolVar;\n                break;\n            }\n            return new ctor({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: M.name,\n            });\n        },\n        Super: function(M) {\n            return new AST_Super({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"super\",\n            });\n        },\n        ThisExpression: function(M) {\n            return new AST_This({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: \"this\",\n            });\n        },\n        ParenthesizedExpression: function(M) {\n            var node = from_moz(M.expression);\n            if (!node.start.parens) node.start.parens = [];\n            node.start.parens.push(my_start_token(M));\n            if (!node.end.parens) node.end.parens = [];\n            node.end.parens.push(my_end_token(M));\n            return node;\n        },\n        ChainExpression: function(M) {\n            var node = from_moz(M.expression);\n            node.terminal = true;\n            return node;\n        },\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    map(\"EmptyStatement\", AST_EmptyStatement);\n    map(\"ExpressionStatement\", AST_SimpleStatement, \"expression>body\");\n    map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n    map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n    map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n    map(\"BreakStatement\", AST_Break, \"label>label\");\n    map(\"ContinueStatement\", AST_Continue, \"label>label\");\n    map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n    map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n    map(\"ReturnStatement\", AST_Return, \"argument>value\");\n    map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n    map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n    map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n    map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n    map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n    map(\"DebuggerStatement\", AST_Debugger);\n    map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n    map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n    map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentPattern\", AST_DefaultValue, \"left>name, right>value\");\n    map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n    map(\"NewExpression\", AST_New, \"callee>expression, arguments@args, pure=pure\");\n    map(\"CallExpression\", AST_Call, \"callee>expression, arguments@args, optional=optional, pure=pure\");\n    map(\"SequenceExpression\", AST_Sequence, \"expressions@expressions\");\n    map(\"SpreadElement\", AST_Spread, \"argument>expression\");\n    map(\"ObjectExpression\", AST_Object, \"properties@properties\");\n    map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n    map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=nested\");\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_LambdaDefinition, function To_Moz_FunctionDeclaration(M) {\n        var params = M.argnames.map(to_moz);\n        if (M.rest) params.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            async: is_async(M),\n            generator: is_generator(M),\n            params: params,\n            body: to_moz_scope(\"BlockStatement\", M),\n        };\n    });\n\n    def_to_moz(AST_Lambda, function To_Moz_FunctionExpression(M) {\n        var params = M.argnames.map(to_moz);\n        if (M.rest) params.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        if (is_arrow(M)) return {\n            type: \"ArrowFunctionExpression\",\n            async: is_async(M),\n            params: params,\n            body: M.value ? to_moz(M.value) : to_moz_scope(\"BlockStatement\", M),\n        };\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            async: is_async(M),\n            generator: is_generator(M),\n            params: params,\n            body: to_moz_scope(\"BlockStatement\", M),\n        };\n    });\n\n    def_to_moz(AST_DefClass, function To_Moz_ClassDeclaration(M) {\n        return {\n            type: \"ClassDeclaration\",\n            id: to_moz(M.name),\n            superClass: to_moz(M.extends),\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz),\n            },\n        };\n    });\n\n    def_to_moz(AST_ClassExpression, function To_Moz_ClassExpression(M) {\n        return {\n            type: \"ClassExpression\",\n            id: to_moz(M.name),\n            superClass: to_moz(M.extends),\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz),\n            },\n        };\n    });\n\n    function To_Moz_MethodDefinition(kind) {\n        return function(M) {\n            var computed = M.key instanceof AST_Node;\n            var key = computed ? to_moz(M.key) : M.private ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.slice(1),\n            } : {\n                type: \"Literal\",\n                value: M.key,\n            };\n            return {\n                type: \"MethodDefinition\",\n                kind: kind,\n                computed: computed,\n                key: key,\n                static: M.static,\n                value: to_moz(M.value),\n            };\n        };\n    }\n    def_to_moz(AST_ClassGetter, To_Moz_MethodDefinition(\"get\"));\n    def_to_moz(AST_ClassSetter, To_Moz_MethodDefinition(\"set\"));\n    def_to_moz(AST_ClassMethod, To_Moz_MethodDefinition(\"method\"));\n\n    def_to_moz(AST_ClassField, function To_Moz_PropertyDefinition(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : M.private ? {\n            type: \"PrivateIdentifier\",\n            name: M.key.slice(1),\n        } : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        return {\n            type: \"PropertyDefinition\",\n            computed: computed,\n            key: key,\n            static: M.static,\n            value: to_moz(M.value),\n        };\n    });\n\n    function To_Moz_ForOfStatement(is_await) {\n        return function(M) {\n            return {\n                type: \"ForOfStatement\",\n                await: is_await,\n                left: to_moz(M.init),\n                right: to_moz(M.object),\n                body: to_moz(M.body),\n            };\n        };\n    }\n    def_to_moz(AST_ForAwaitOf, To_Moz_ForOfStatement(true));\n    def_to_moz(AST_ForOf, To_Moz_ForOfStatement(false));\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: set_moz_loc(M, {\n                type: \"Literal\",\n                value: M.value,\n            }),\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M),\n            handler: to_moz(M.bcatch),\n            guardedHandlers: [],\n            finalizer: to_moz(M.bfinally),\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: to_moz(M.argname),\n            guard: null,\n            body: to_moz_block(M),\n        };\n    });\n\n    def_to_moz(AST_ExportDeclaration, function To_Moz_ExportNamedDeclaration_declaration(M) {\n        return {\n            type: \"ExportNamedDeclaration\",\n            declaration: to_moz(M.body),\n        };\n    });\n\n    def_to_moz(AST_ExportDefault, function To_Moz_ExportDefaultDeclaration(M) {\n        return {\n            type: \"ExportDefaultDeclaration\",\n            declaration: to_moz(M.body),\n        };\n    });\n\n    def_to_moz(AST_ExportForeign, function To_Moz_ExportAllDeclaration_ExportNamedDeclaration(M) {\n        if (M.keys[0] == \"*\") return {\n            type: \"ExportAllDeclaration\",\n            exported: M.aliases[0] == \"*\" ? null : {\n                type: \"Identifier\",\n                name: M.aliases[0],\n            },\n            source: {\n                type: \"Literal\",\n                value: M.path,\n            },\n        };\n        var specifiers = [];\n        for (var i = 0; i < M.aliases.length; i++) {\n            specifiers.push({\n                type: \"ExportSpecifier\",\n                exported: {\n                    type: \"Identifier\",\n                    name: M.aliases[i],\n                },\n                local: {\n                    type: \"Identifier\",\n                    name: M.keys[i],\n                },\n            });\n        }\n        return {\n            type: \"ExportNamedDeclaration\",\n            specifiers: specifiers,\n            source: {\n                type: \"Literal\",\n                value: M.path,\n            },\n        };\n    });\n\n    def_to_moz(AST_ExportReferences, function To_Moz_ExportNamedDeclaration_specifiers(M) {\n        return {\n            type: \"ExportNamedDeclaration\",\n            specifiers: M.properties.map(function(prop) {\n                return {\n                    type: \"ExportSpecifier\",\n                    local: to_moz(prop),\n                    exported: {\n                        type: \"Identifier\",\n                        name: prop.alias,\n                    },\n                };\n            }),\n        };\n    });\n\n    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n        var specifiers = M.properties ? M.properties.map(function(prop) {\n            return {\n                type: \"ImportSpecifier\",\n                local: to_moz(prop),\n                imported: {\n                    type: \"Identifier\",\n                    name: prop.key,\n                },\n            };\n        }) : [];\n        if (M.all) specifiers.unshift({\n            type: \"ImportNamespaceSpecifier\",\n            local: to_moz(M.all),\n        });\n        if (M.default) specifiers.unshift({\n            type: \"ImportDefaultSpecifier\",\n            local: to_moz(M.default),\n        });\n        return {\n            type: \"ImportDeclaration\",\n            specifiers: specifiers,\n            source: {\n                type: \"Literal\",\n                value: M.path,\n            },\n        };\n    });\n\n    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind: M.TYPE.toLowerCase(),\n            declarations: M.definitions.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var computed = M instanceof AST_Sub;\n        var expr = {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: computed,\n            optional: M.optional,\n            property: computed ? to_moz(M.property) : {\n                type: \"Identifier\",\n                name: M.property,\n            },\n        };\n        return M.terminal ? {\n            type: \"ChainExpression\",\n            expression: expr,\n        } : expr;\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        return {\n            type: M.operator == \"&&\" || M.operator == \"||\" ? \"LogicalExpression\" : \"BinaryExpression\",\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz),\n        };\n    });\n\n    def_to_moz(AST_DestructuredArray, function To_Moz_ArrayPattern(M) {\n        var elements = M.elements.map(to_moz);\n        if (M.rest) elements.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"ArrayPattern\",\n            elements: elements,\n        };\n    });\n\n    def_to_moz(AST_DestructuredKeyVal, function To_Moz_Property(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        return {\n            type: \"Property\",\n            kind: \"init\",\n            computed: computed,\n            key: key,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_DestructuredObject, function To_Moz_ObjectPattern(M) {\n        var props = M.properties.map(to_moz);\n        if (M.rest) props.push({\n            type: \"RestElement\",\n            argument: to_moz(M.rest),\n        });\n        return {\n            type: \"ObjectPattern\",\n            properties: props,\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M) {\n        var computed = M.key instanceof AST_Node;\n        var key = computed ? to_moz(M.key) : {\n            type: \"Literal\",\n            value: M.key,\n        };\n        var kind;\n        if (M instanceof AST_ObjectKeyVal) {\n            kind = \"init\";\n        } else if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        return {\n            type: \"Property\",\n            kind: kind,\n            computed: computed,\n            method: M instanceof AST_ObjectMethod,\n            key: key,\n            value: to_moz(M.value),\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M) {\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def && def.mangled_name || M.name,\n        };\n    });\n\n    def_to_moz(AST_Super, function To_Moz_Super() {\n        return { type: \"Super\" };\n    });\n\n    def_to_moz(AST_This, function To_Moz_ThisExpression() {\n        return { type: \"ThisExpression\" };\n    });\n\n    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"new\",\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"target\",\n            },\n        };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        var flags = M.value.toString().match(/\\/([gimuy]*)$/)[1];\n        var value = \"/\" + M.value.raw_source + \"/\" + flags;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: value,\n            regex: {\n                pattern: M.value.raw_source,\n                flags: flags,\n            },\n        };\n    });\n\n    def_to_moz(AST_BigInt, function To_Moz_BigInt(M) {\n        var value = M.value;\n        return {\n            type: \"Literal\",\n            bigint: value.slice(0, -1),\n            raw: value,\n        };\n    });\n\n    function To_Moz_Literal(M) {\n        var value = M.value;\n        if (typeof value === \"number\" && (value < 0 || (value === 0 && 1 / value < 0))) {\n            return {\n                type: \"UnaryExpression\",\n                operator: \"-\",\n                prefix: true,\n                argument: {\n                    type: \"Literal\",\n                    value: -value,\n                    raw: M.start.raw,\n                },\n            };\n        }\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.start.raw,\n        };\n    }\n    def_to_moz(AST_Boolean, To_Moz_Literal);\n    def_to_moz(AST_Constant, To_Moz_Literal);\n    def_to_moz(AST_Null, To_Moz_Literal);\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value),\n        };\n    });\n\n    def_to_moz(AST_Template, function To_Moz_TemplateLiteral_TaggedTemplateExpression(M) {\n        var last = M.strings.length - 1;\n        var tmpl = {\n            type: \"TemplateLiteral\",\n            expressions: M.expressions.map(to_moz),\n            quasis: M.strings.map(function(str, index) {\n                return {\n                    type: \"TemplateElement\",\n                    tail: index == last,\n                    value: { raw: str },\n                };\n            }),\n        };\n        if (!M.tag) return tmpl;\n        return {\n            type: \"TaggedTemplateExpression\",\n            tag: to_moz(M.tag),\n            quasi: tmpl,\n        };\n    });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", return_null);\n    AST_Node.DEFMETHOD(\"to_mozilla_ast\", function() {\n        throw new Error(\"Cannot convert AST_\" + this.TYPE);\n    });\n\n    /* -----[ tools ]----- */\n\n    function normalize_directives(body) {\n        for (var i = 0; i < body.length; i++) {\n            var stat = body[i];\n            if (!(stat instanceof AST_SimpleStatement)) break;\n            var node = stat.body;\n            if (!(node instanceof AST_String)) break;\n            if (stat.start.pos !== node.start.pos) break;\n            body[i] = new AST_Directive(node);\n        }\n        return body;\n    }\n\n    function raw_token(moznode) {\n        if (moznode.type == \"Literal\") {\n            return moznode.raw != null ? moznode.raw : moznode.value + \"\";\n        }\n    }\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : start && start.line,\n            col     : start && start.column,\n            pos     : range ? range[0] : moznode.start,\n            endline : start && start.line,\n            endcol  : start && start.column,\n            endpos  : range ? range[0] : moznode.start,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token({\n            file    : loc && loc.source,\n            line    : end && end.line,\n            col     : end && end.column,\n            pos     : range ? range[1] : moznode.end,\n            endline : end && end.line,\n            endcol  : end && end.column,\n            endpos  : range ? range[1] : moznode.end,\n            raw     : raw_token(moznode),\n        });\n    }\n\n    function read_name(M) {\n        return \"\" + M[M.type == \"Identifier\" ? \"name\" : \"value\"];\n    }\n\n    function map(moztype, mytype, propmap) {\n        var moz_to_me = [\n            \"start: my_start_token(M)\",\n            \"end: my_end_token(M)\",\n        ];\n        var me_to_moz = [\n            \"type: \" + JSON.stringify(moztype),\n        ];\n\n        if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n            var m = /([a-z0-9$_]+)(=|@|>|%)([a-z0-9$_]+)/i.exec(prop);\n            if (!m) throw new Error(\"Can't understand property map: \" + prop);\n            var moz = m[1], how = m[2], my = m[3];\n            switch (how) {\n              case \"@\":\n                moz_to_me.push(my + \": M.\" + moz + \".map(from_moz)\");\n                me_to_moz.push(moz + \": M.\" +  my + \".map(to_moz)\");\n                break;\n              case \">\":\n                moz_to_me.push(my + \": from_moz(M.\" + moz + \")\");\n                me_to_moz.push(moz + \": to_moz(M.\" + my + \")\");\n                break;\n              case \"=\":\n                moz_to_me.push(my + \": M.\" + moz);\n                me_to_moz.push(moz + \": M.\" + my);\n                break;\n              case \"%\":\n                moz_to_me.push(my + \": from_moz(M.\" + moz + \").body\");\n                me_to_moz.push(moz + \": to_moz_block(M)\");\n                break;\n              default:\n                throw new Error(\"Can't understand operator in propmap: \" + prop);\n            }\n        });\n\n        MOZ_TO_ME[moztype] = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", [\n            \"return function From_Moz_\" + moztype + \"(M) {\",\n            \"    return new U2.AST_\" + mytype.TYPE + \"({\",\n            moz_to_me.join(\",\\n\"),\n            \"    });\",\n            \"};\",\n        ].join(\"\\n\"))(exports, my_start_token, my_end_token, from_moz);\n        def_to_moz(mytype, new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", [\n            \"return function To_Moz_\" + moztype + \"(M) {\",\n            \"    return {\",\n            me_to_moz.join(\",\\n\"),\n            \"    };\",\n            \"};\",\n        ].join(\"\\n\"))(to_moz, to_moz_block, to_moz_scope));\n    }\n\n    var FROM_MOZ_STACK = null;\n\n    function from_moz(moz) {\n        FROM_MOZ_STACK.push(moz);\n        var node = null;\n        if (moz) {\n            if (!HOP(MOZ_TO_ME, moz.type)) throw new Error(\"Unsupported type: \" + moz.type);\n            node = MOZ_TO_ME[moz.type](moz);\n        }\n        FROM_MOZ_STACK.pop();\n        return node;\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_stack = FROM_MOZ_STACK;\n        FROM_MOZ_STACK = [];\n        var ast = from_moz(node);\n        FROM_MOZ_STACK = save_stack;\n        ast.walk(new TreeWalker(function(node) {\n            if (node instanceof AST_LabelRef) {\n                for (var level = 0, parent; parent = this.parent(level); level++) {\n                    if (parent instanceof AST_Scope) break;\n                    if (parent instanceof AST_LabeledStatement && parent.label.name == node.name) {\n                        node.thedef = parent.label;\n                        break;\n                    }\n                }\n                if (!node.thedef) {\n                    var s = node.start;\n                    js_error(\"Undefined label \" + node.name, s.file, s.line, s.col, s.pos);\n                }\n            }\n        }));\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null,\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function() {\n            return set_moz_loc(this, handler(this));\n        });\n    }\n\n    function to_moz(node) {\n        return node != null ? node.to_mozilla_ast() : null;\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz),\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body,\n        };\n    }\n})();\n"]},"metadata":{},"sourceType":"script"}