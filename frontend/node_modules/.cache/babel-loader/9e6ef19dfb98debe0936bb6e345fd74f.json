{"ast":null,"code":"/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n(function (root, factory) {\n  if (typeof exports === \"object\" && exports) {\n    module.exports = factory; // CommonJS\n  } else if (typeof define === \"function\" && define.amd) {\n    define(factory); // AMD\n  } else {\n    root.Mustache = factory; // <script>\n  }\n})(this, function () {\n  var exports = {};\n  exports.name = \"mustache.js\";\n  exports.version = \"0.7.2\";\n  exports.tags = [\"{{\", \"}}\"];\n  exports.Scanner = Scanner;\n  exports.Context = Context;\n  exports.Writer = Writer;\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var nonSpaceRe = /\\S/;\n  var eqRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/; // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n\n  function testRe(re, string) {\n    return RegExp.prototype.test.call(re, string);\n  }\n\n  function isWhitespace(string) {\n    return !testRe(nonSpaceRe, string);\n  }\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  function escapeRe(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  } // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n\n\n  exports.escape = escapeHtml;\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n\n\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n\n\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      this.tail = this.tail.substring(match[0].length);\n      this.pos += match[0].length;\n      return match[0];\n    }\n\n    return \"\";\n  };\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n\n\n  Scanner.prototype.scanUntil = function (re) {\n    var match,\n        pos = this.tail.search(re);\n\n    switch (pos) {\n      case -1:\n        match = this.tail;\n        this.pos += this.tail.length;\n        this.tail = \"\";\n        break;\n\n      case 0:\n        match = \"\";\n        break;\n\n      default:\n        match = this.tail.substring(0, pos);\n        this.tail = this.tail.substring(pos);\n        this.pos += pos;\n    }\n\n    return match;\n  };\n\n  function Context(view, parent) {\n    this.view = view;\n    this.parent = parent;\n    this._cache = {};\n  }\n\n  Context.make = function (view) {\n    return view instanceof Context ? view : new Context(view);\n  };\n\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  Context.prototype.lookup = function (name) {\n    var value = this._cache[name];\n\n    if (!value) {\n      if (name == '.') {\n        value = this.view;\n      } else {\n        var context = this;\n\n        while (context) {\n          if (name.indexOf('.') > 0) {\n            value = context.view;\n            var names = name.split('.'),\n                i = 0;\n\n            while (value && i < names.length) {\n              value = value[names[i++]];\n            }\n          } else {\n            value = context.view[name];\n          }\n\n          if (value != null) break;\n          context = context.parent;\n        }\n      }\n\n      this._cache[name] = value;\n    }\n\n    if (typeof value === 'function') value = value.call(this.view);\n    return value;\n  };\n\n  function Writer() {\n    this.clearCache();\n  }\n\n  Writer.prototype.clearCache = function () {\n    this._cache = {};\n    this._partialCache = {};\n  };\n\n  Writer.prototype.compile = function (template, tags) {\n    var fn = this._cache[template];\n\n    if (!fn) {\n      var tokens = exports.parse(template, tags);\n      fn = this._cache[template] = this.compileTokens(tokens, template);\n    }\n\n    return fn;\n  };\n\n  Writer.prototype.compilePartial = function (name, template, tags) {\n    var fn = this.compile(template, tags);\n    this._partialCache[name] = fn;\n    return fn;\n  };\n\n  Writer.prototype.getPartial = function (name) {\n    if (!(name in this._partialCache) && this._loadPartial) {\n      this.compilePartial(name, this._loadPartial(name));\n    }\n\n    return this._partialCache[name];\n  };\n\n  Writer.prototype.compileTokens = function (tokens, template) {\n    var self = this;\n    return function (view, partials) {\n      if (partials) {\n        if (typeof partials === 'function') {\n          self._loadPartial = partials;\n        } else {\n          for (var name in partials) {\n            self.compilePartial(name, partials[name]);\n          }\n        }\n      }\n\n      return renderTokens(tokens, self, Context.make(view), template);\n    };\n  };\n\n  Writer.prototype.render = function (template, view, partials) {\n    return this.compile(template)(view, partials);\n  };\n  /**\n   * Low-level function that renders the given `tokens` using the given `writer`\n   * and `context`. The `template` string is only needed for templates that use\n   * higher-order sections to extract the portion of the original template that\n   * was contained in that section.\n   */\n\n\n  function renderTokens(tokens, writer, context, template) {\n    var buffer = '';\n    var token, tokenValue, value;\n\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      tokenValue = token[1];\n\n      switch (token[0]) {\n        case '#':\n          value = context.lookup(tokenValue);\n\n          if (typeof value === 'object') {\n            if (isArray(value)) {\n              for (var j = 0, jlen = value.length; j < jlen; ++j) {\n                buffer += renderTokens(token[4], writer, context.push(value[j]), template);\n              }\n            } else if (value) {\n              buffer += renderTokens(token[4], writer, context.push(value), template);\n            }\n          } else if (typeof value === 'function') {\n            var text = template == null ? null : template.slice(token[3], token[5]);\n            value = value.call(context.view, text, function (template) {\n              return writer.render(template, context);\n            });\n            if (value != null) buffer += value;\n          } else if (value) {\n            buffer += renderTokens(token[4], writer, context, template);\n          }\n\n          break;\n\n        case '^':\n          value = context.lookup(tokenValue); // Use JavaScript's definition of falsy. Include empty arrays.\n          // See https://github.com/janl/mustache.js/issues/186\n\n          if (!value || isArray(value) && value.length === 0) {\n            buffer += renderTokens(token[4], writer, context, template);\n          }\n\n          break;\n\n        case '>':\n          value = writer.getPartial(tokenValue);\n          if (typeof value === 'function') buffer += value(context);\n          break;\n\n        case '&':\n          value = context.lookup(tokenValue);\n          if (value != null) buffer += value;\n          break;\n\n        case 'name':\n          value = context.lookup(tokenValue);\n          if (value != null) buffer += exports.escape(value);\n          break;\n\n        case 'text':\n          buffer += tokenValue;\n          break;\n      }\n    }\n\n    return buffer;\n  }\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n\n\n  function nestTokens(tokens) {\n    var tree = [];\n    var collector = tree;\n    var sections = [];\n    var token;\n\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n\n      switch (token[0]) {\n        case '#':\n        case '^':\n          sections.push(token);\n          collector.push(token);\n          collector = token[4] = [];\n          break;\n\n        case '/':\n          var section = sections.pop();\n          section[5] = token[2];\n          collector = sections.length > 0 ? sections[sections.length - 1][4] : tree;\n          break;\n\n        default:\n          collector.push(token);\n      }\n    }\n\n    return tree;\n  }\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n\n\n  function squashTokens(tokens) {\n    var squashedTokens = [];\n    var token, lastToken;\n\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          lastToken = token;\n          squashedTokens.push(token);\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  function escapeTags(tags) {\n    return [new RegExp(escapeRe(tags[0]) + \"\\\\s*\"), new RegExp(\"\\\\s*\" + escapeRe(tags[1]))];\n  }\n  /**\n   * Breaks up the given `template` string into a tree of token objects. If\n   * `tags` is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [\"<%\", \"%>\"]). Of\n   * course, the default is to use mustaches (i.e. Mustache.tags).\n   */\n\n\n  exports.parse = function (template, tags) {\n    template = template || '';\n    tags = tags || exports.tags;\n    if (typeof tags === 'string') tags = tags.split(spaceRe);\n    if (tags.length !== 2) throw new Error('Invalid tags: ' + tags.join(', '));\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n    var sections = []; // Stack to hold section tokens\n\n    var tokens = []; // Buffer to hold the tokens\n\n    var spaces = []; // Indices of whitespace tokens on the current line\n\n    var hasTag = false; // Is there a {{tag}} on the current line?\n\n    var nonSpace = false; // Is there a non-space char on the current line?\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          delete tokens[spaces.pop()];\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr, token;\n\n    while (!scanner.eos()) {\n      start = scanner.pos; // Match any text between tags.\n\n      value = scanner.scanUntil(tagRes[0]);\n\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push(['text', chr, start, start + 1]);\n          start += 1; // Check for whitespace on the current line.\n\n          if (chr == '\\n') stripSpace();\n        }\n      } // Match the opening tag.\n\n\n      if (!scanner.scan(tagRes[0])) break;\n      hasTag = true; // Get the tag type.\n\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe); // Get the tag value.\n\n      if (type === '=') {\n        value = scanner.scanUntil(eqRe);\n        scanner.scan(eqRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === '{') {\n        value = scanner.scanUntil(new RegExp('\\\\s*' + escapeRe('}' + tags[1])));\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      } // Match the closing tag.\n\n\n      if (!scanner.scan(tagRes[1])) throw new Error('Unclosed tag at ' + scanner.pos);\n      token = [type, value, start, scanner.pos];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        if (sections.length === 0) throw new Error('Unopened section \"' + value + '\" at ' + start);\n        var openSection = sections.pop();\n        if (openSection[1] !== value) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        tags = value.split(spaceRe);\n        if (tags.length !== 2) throw new Error('Invalid tags at ' + start + ': ' + tags.join(', '));\n        tagRes = escapeTags(tags);\n      }\n    } // Make sure there are no open sections when we're done.\n\n\n    var openSection = sections.pop();\n    if (openSection) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n    tokens = squashTokens(tokens);\n    return nestTokens(tokens);\n  }; // All Mustache.* functions use this writer.\n\n\n  var _writer = new Writer();\n  /**\n   * Clears all cached templates and partials in the default writer.\n   */\n\n\n  exports.clearCache = function () {\n    return _writer.clearCache();\n  };\n  /**\n   * Compiles the given `template` to a reusable function using the default\n   * writer.\n   */\n\n\n  exports.compile = function (template, tags) {\n    return _writer.compile(template, tags);\n  };\n  /**\n   * Compiles the partial with the given `name` and `template` to a reusable\n   * function using the default writer.\n   */\n\n\n  exports.compilePartial = function (name, template, tags) {\n    return _writer.compilePartial(name, template, tags);\n  };\n  /**\n   * Compiles the given array of tokens (the output of a parse) to a reusable\n   * function using the default writer.\n   */\n\n\n  exports.compileTokens = function (tokens, template) {\n    return _writer.compileTokens(tokens, template);\n  };\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n\n\n  exports.render = function (template, view, partials) {\n    return _writer.render(template, view, partials);\n  }; // This is here for backwards compatibility with 0.4.x.\n\n\n  exports.to_html = function (template, view, partials, send) {\n    var result = exports.render(template, view, partials);\n\n    if (typeof send === \"function\") {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  return exports;\n}());","map":{"version":3,"sources":["/home/harsha/Desktop/ug2 spring SEM2/DAss/mongo/frontend/node_modules/fuse/lib/mustache.js"],"names":["root","factory","exports","module","define","amd","Mustache","name","version","tags","Scanner","Context","Writer","whiteRe","spaceRe","nonSpaceRe","eqRe","curlyRe","tagRe","testRe","re","string","RegExp","prototype","test","call","isWhitespace","isArray","Array","obj","Object","toString","escapeRe","replace","entityMap","escapeHtml","String","s","escape","tail","pos","eos","scan","match","index","substring","length","scanUntil","search","view","parent","_cache","make","push","lookup","value","context","indexOf","names","split","i","clearCache","_partialCache","compile","template","fn","tokens","parse","compileTokens","compilePartial","getPartial","_loadPartial","self","partials","renderTokens","render","writer","buffer","token","tokenValue","len","j","jlen","text","slice","nestTokens","tree","collector","sections","section","pop","squashTokens","squashedTokens","lastToken","escapeTags","Error","join","tagRes","scanner","spaces","hasTag","nonSpace","stripSpace","start","type","chr","charAt","openSection","_writer","to_html","send","result"],"mappings":"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","sourcesContent":["/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\n(function (root, factory) {\n  if (typeof exports === \"object\" && exports) {\n    module.exports = factory; // CommonJS\n  } else if (typeof define === \"function\" && define.amd) {\n    define(factory); // AMD\n  } else {\n    root.Mustache = factory; // <script>\n  }\n}(this, (function () {\n\n  var exports = {};\n\n  exports.name = \"mustache.js\";\n  exports.version = \"0.7.2\";\n  exports.tags = [\"{{\", \"}}\"];\n\n  exports.Scanner = Scanner;\n  exports.Context = Context;\n  exports.Writer = Writer;\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var nonSpaceRe = /\\S/;\n  var eqRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  function testRe(re, string) {\n    return RegExp.prototype.test.call(re, string);\n  }\n\n  function isWhitespace(string) {\n    return !testRe(nonSpaceRe, string);\n  }\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  function escapeRe(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  exports.escape = escapeHtml;\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      this.tail = this.tail.substring(match[0].length);\n      this.pos += match[0].length;\n      return match[0];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var match, pos = this.tail.search(re);\n\n    switch (pos) {\n    case -1:\n      match = this.tail;\n      this.pos += this.tail.length;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, pos);\n      this.tail = this.tail.substring(pos);\n      this.pos += pos;\n    }\n\n    return match;\n  };\n\n  function Context(view, parent) {\n    this.view = view;\n    this.parent = parent;\n    this._cache = {};\n  }\n\n  Context.make = function (view) {\n    return (view instanceof Context) ? view : new Context(view);\n  };\n\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  Context.prototype.lookup = function (name) {\n    var value = this._cache[name];\n\n    if (!value) {\n      if (name == '.') {\n        value = this.view;\n      } else {\n        var context = this;\n\n        while (context) {\n          if (name.indexOf('.') > 0) {\n            value = context.view;\n            var names = name.split('.'), i = 0;\n            while (value && i < names.length) {\n              value = value[names[i++]];\n            }\n          } else {\n            value = context.view[name];\n          }\n\n          if (value != null) break;\n\n          context = context.parent;\n        }\n      }\n\n      this._cache[name] = value;\n    }\n\n    if (typeof value === 'function') value = value.call(this.view);\n\n    return value;\n  };\n\n  function Writer() {\n    this.clearCache();\n  }\n\n  Writer.prototype.clearCache = function () {\n    this._cache = {};\n    this._partialCache = {};\n  };\n\n  Writer.prototype.compile = function (template, tags) {\n    var fn = this._cache[template];\n\n    if (!fn) {\n      var tokens = exports.parse(template, tags);\n      fn = this._cache[template] = this.compileTokens(tokens, template);\n    }\n\n    return fn;\n  };\n\n  Writer.prototype.compilePartial = function (name, template, tags) {\n    var fn = this.compile(template, tags);\n    this._partialCache[name] = fn;\n    return fn;\n  };\n\n  Writer.prototype.getPartial = function (name) {\n    if (!(name in this._partialCache) && this._loadPartial) {\n      this.compilePartial(name, this._loadPartial(name));\n    }\n\n    return this._partialCache[name];\n  };\n\n  Writer.prototype.compileTokens = function (tokens, template) {\n    var self = this;\n    return function (view, partials) {\n      if (partials) {\n        if (typeof partials === 'function') {\n          self._loadPartial = partials;\n        } else {\n          for (var name in partials) {\n            self.compilePartial(name, partials[name]);\n          }\n        }\n      }\n\n      return renderTokens(tokens, self, Context.make(view), template);\n    };\n  };\n\n  Writer.prototype.render = function (template, view, partials) {\n    return this.compile(template)(view, partials);\n  };\n\n  /**\n   * Low-level function that renders the given `tokens` using the given `writer`\n   * and `context`. The `template` string is only needed for templates that use\n   * higher-order sections to extract the portion of the original template that\n   * was contained in that section.\n   */\n  function renderTokens(tokens, writer, context, template) {\n    var buffer = '';\n\n    var token, tokenValue, value;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      tokenValue = token[1];\n\n      switch (token[0]) {\n      case '#':\n        value = context.lookup(tokenValue);\n\n        if (typeof value === 'object') {\n          if (isArray(value)) {\n            for (var j = 0, jlen = value.length; j < jlen; ++j) {\n              buffer += renderTokens(token[4], writer, context.push(value[j]), template);\n            }\n          } else if (value) {\n            buffer += renderTokens(token[4], writer, context.push(value), template);\n          }\n        } else if (typeof value === 'function') {\n          var text = template == null ? null : template.slice(token[3], token[5]);\n          value = value.call(context.view, text, function (template) {\n            return writer.render(template, context);\n          });\n          if (value != null) buffer += value;\n        } else if (value) {\n          buffer += renderTokens(token[4], writer, context, template);\n        }\n\n        break;\n      case '^':\n        value = context.lookup(tokenValue);\n\n        // Use JavaScript's definition of falsy. Include empty arrays.\n        // See https://github.com/janl/mustache.js/issues/186\n        if (!value || (isArray(value) && value.length === 0)) {\n          buffer += renderTokens(token[4], writer, context, template);\n        }\n\n        break;\n      case '>':\n        value = writer.getPartial(tokenValue);\n        if (typeof value === 'function') buffer += value(context);\n        break;\n      case '&':\n        value = context.lookup(tokenValue);\n        if (value != null) buffer += value;\n        break;\n      case 'name':\n        value = context.lookup(tokenValue);\n        if (value != null) buffer += exports.escape(value);\n        break;\n      case 'text':\n        buffer += tokenValue;\n        break;\n      }\n    }\n\n    return buffer;\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens(tokens) {\n    var tree = [];\n    var collector = tree;\n    var sections = [];\n\n    var token;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      switch (token[0]) {\n      case '#':\n      case '^':\n        sections.push(token);\n        collector.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        var section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : tree;\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    return tree;\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      if (token) {\n        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n          lastToken[1] += token[1];\n          lastToken[3] = token[3];\n        } else {\n          lastToken = token;\n          squashedTokens.push(token);\n        }\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  function escapeTags(tags) {\n    return [\n      new RegExp(escapeRe(tags[0]) + \"\\\\s*\"),\n      new RegExp(\"\\\\s*\" + escapeRe(tags[1]))\n    ];\n  }\n\n  /**\n   * Breaks up the given `template` string into a tree of token objects. If\n   * `tags` is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [\"<%\", \"%>\"]). Of\n   * course, the default is to use mustaches (i.e. Mustache.tags).\n   */\n  exports.parse = function (template, tags) {\n    template = template || '';\n    tags = tags || exports.tags;\n\n    if (typeof tags === 'string') tags = tags.split(spaceRe);\n    if (tags.length !== 2) throw new Error('Invalid tags: ' + tags.join(', '));\n\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          delete tokens[spaces.pop()];\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr, token;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n\n      // Match any text between tags.\n      value = scanner.scanUntil(tagRes[0]);\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push(['text', chr, start, start + 1]);\n          start += 1;\n\n          // Check for whitespace on the current line.\n          if (chr == '\\n') stripSpace();\n        }\n      }\n\n      // Match the opening tag.\n      if (!scanner.scan(tagRes[0])) break;\n      hasTag = true;\n\n      // Get the tag type.\n      type = scanner.scan(tagRe) || 'name';\n      scanner.scan(whiteRe);\n\n      // Get the tag value.\n      if (type === '=') {\n        value = scanner.scanUntil(eqRe);\n        scanner.scan(eqRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === '{') {\n        value = scanner.scanUntil(new RegExp('\\\\s*' + escapeRe('}' + tags[1])));\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = '&';\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(tagRes[1])) throw new Error('Unclosed tag at ' + scanner.pos);\n\n      token = [type, value, start, scanner.pos];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === '/') {\n        // Check section nesting.\n        if (sections.length === 0) throw new Error('Unopened section \"' + value + '\" at ' + start);\n        var openSection = sections.pop();\n        if (openSection[1] !== value) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n      } else if (type === 'name' || type === '{' || type === '&') {\n        nonSpace = true;\n      } else if (type === '=') {\n        // Set the tags for the next time around.\n        tags = value.split(spaceRe);\n        if (tags.length !== 2) throw new Error('Invalid tags at ' + start + ': ' + tags.join(', '));\n        tagRes = escapeTags(tags);\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    var openSection = sections.pop();\n    if (openSection) throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n    tokens = squashTokens(tokens);\n\n    return nestTokens(tokens);\n  };\n\n  // All Mustache.* functions use this writer.\n  var _writer = new Writer();\n\n  /**\n   * Clears all cached templates and partials in the default writer.\n   */\n  exports.clearCache = function () {\n    return _writer.clearCache();\n  };\n\n  /**\n   * Compiles the given `template` to a reusable function using the default\n   * writer.\n   */\n  exports.compile = function (template, tags) {\n    return _writer.compile(template, tags);\n  };\n\n  /**\n   * Compiles the partial with the given `name` and `template` to a reusable\n   * function using the default writer.\n   */\n  exports.compilePartial = function (name, template, tags) {\n    return _writer.compilePartial(name, template, tags);\n  };\n\n  /**\n   * Compiles the given array of tokens (the output of a parse) to a reusable\n   * function using the default writer.\n   */\n  exports.compileTokens = function (tokens, template) {\n    return _writer.compileTokens(tokens, template);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  exports.render = function (template, view, partials) {\n    return _writer.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  exports.to_html = function (template, view, partials, send) {\n    var result = exports.render(template, view, partials);\n\n    if (typeof send === \"function\") {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  return exports;\n\n}())));"]},"metadata":{},"sourceType":"script"}