{"ast":null,"code":"(function () {\n  \"use strict\";\n\n  var colors = require('colors');\n\n  var fs = require('fs');\n\n  var _ = require('underscore');\n\n  var path = require('path');\n\n  var ujs = require('uglify-js');\n\n  var jshint = require('jshint').JSHINT;\n\n  var sys = require('sys');\n\n  var mustache = require('./mustache.js');\n\n  var util = require('util');\n\n  var EventEmitter = require('events').EventEmitter;\n\n  function Fuse() {\n    this.settings = {}; // setup the regular expressions\n\n    this.re = this.reJS = /\\/\\/ ?@(?:depends|import|include) (.+)\\b/gi;\n    this.reHTML = /<!--\\s?@(?:depends|import|include)\\s(.+?)\\s?-->/gi; // not watching by default\n\n    this.watching = false; // create an array to hold the watches for this fuse\n\n    this.files = [];\n    return this;\n  }\n\n  util.inherits(Fuse, EventEmitter);\n\n  Fuse.prototype.set = function (setting, val) {\n    this.settings[setting] = val;\n    return this;\n  };\n\n  Fuse.prototype.get = function (setting) {\n    return this.settings[setting];\n  };\n\n  Fuse.prototype.watch = function (inputFile, outputFile, fuseImmediately) {\n    var _this = this;\n\n    if (arguments.length === 1) {\n      fuseImmediately = inputFile;\n      inputFile = undefined;\n    }\n\n    if (inputFile) this.set('inputFile', inputFile);\n    if (outputFile) this.set('outputFile', outputFile);\n    if (this.get('inputFile') === undefined) throw new Error('You must define the input file.');\n    if (this.get('outputFile') === undefined) throw new Error('You must define the output file.'); // what mode are we running in, HTML or JS?\n    // this needs to be improved, because it means it will only work if the file ext is 'html' || 'js'\n\n    this.mode = path.extname(this.get('inputFile')).replace(/^\\./, ''); // swtich the regular expression based on mode\n\n    this.regex = this.mode === 'js' ? this.reJS : this.reHTML; // define the watching mode\n\n    this.watching = true; // retrieve a list of files to watch\n\n    var aFiles = this.scanFiles();\n    var relativePath = path.dirname(this.get('inputFile')) + '/'; // loop through an setup a watch on each referenced file\n\n    _(aFiles).each(function (path) {\n      _this.watchSrcFile(relativePath + path.path);\n\n      _this.files.push(relativePath + path.path);\n    }); // we also need to watch the input file\n\n\n    this.watchFile(this.get('inputFile'));\n    this.files.push(this.get('inputFile'));\n    if (fuseImmediately) this.fuseFile();\n    return this;\n  };\n\n  Fuse.prototype.scanFiles = function () {\n    return this.getReferencedFiles(this.getFileContent(this.get('inputFile')), this.regex);\n  };\n\n  Fuse.prototype.checkReferences = function (references) {\n    var _this = this,\n        files = [this.get('inputFile')],\n        relativePath = path.dirname(this.get('inputFile')) + '/',\n        unwatched = false; // find references that are missing from files (these are files that need to be watched)\n\n\n    references.forEach(function (reference) {\n      var found = _this.files.some(function (file) {\n        return path.resolve(file) === path.resolve(relativePath, reference.path);\n      }); // add the file regardless if its found or not, because we're rebulding the files array\n\n\n      files.push(relativePath + reference.path); // if the file is in the files array, let's add it and start watching\n\n      if (!found) _this.watchSrcFile(relativePath + reference.path);\n    }); // find files that are missing from references (this are files that need to be unwatched)\n\n    this.files.forEach(function (file) {\n      // ignore the input file, we've already added this\n      if (file === _this.get('inputFile')) return; // search for this file in references\n\n      var found = references.some(function (reference) {\n        return path.resolve(file) === path.resolve(relativePath, reference.path);\n      }); // references is newer then file, so it may have been removed\n\n      if (!found) {\n        _this.unwatchSrcFile(file);\n\n        unwatched = true;\n      }\n    }); // update the old array, with the new one\n\n    this.files = files;\n    return unwatched;\n  };\n\n  Fuse.prototype.formatTime = function () {\n    var d = new Date();\n    return [d.getHours(), ':', d.getMinutes(), '.', d.getSeconds()].join('');\n  }; // core function for parsing and outputing a fused file\n  // uses fuseContent to do the heavy lifting\n\n\n  Fuse.prototype.fuseFile = function (inputFile, outputFile) {\n    if (inputFile !== undefined) this.set('inputFile', inputFile);\n    if (outputFile !== undefined) this.set('outputFile', outputFile);\n    if (this.get('inputFile') === undefined) throw new Error('You must define the input file.');\n    if (this.get('outputFile') === undefined) throw new Error('You must define the output file.'); // what mode are we running in, HTML or JS?\n    // this needs to be improved, because it means it will only work if the file ext is 'html' || 'js'\n\n    this.mode = path.extname(this.get('inputFile')).replace(/^\\./, ''); // swtich the regular expression based on mode\n\n    this.regex = this.mode === 'js' ? this.reJS : this.reHTML; // work out the settings\n    // do we need to compress (js only)?\n\n    this.compress = this.get('compress') !== undefined ? this.get('compress') && this.mode === 'js' : false; // do we need to mangle (js only)?\n\n    this.mangle = this.get('mangle') !== undefined ? this.get('mangle') && this.mode === 'js' : false; // do we need to run the files through JSHint (js only)?\n\n    this.lint = this.get('lint') !== undefined ? this.get('lint') && this.mode === 'js' : false; // grab the content of the input file\n\n    var content = this.getFileContent(this.get('inputFile')); // determine the relative path we need to work from\n\n    var relativePath = path.dirname(path.normalize(this.get('inputFile'))); // grab a list of the referenced files\n\n    var matches = this.getReferencedFiles(content, this.regex); // output is a version of the content that we'll update\n\n    var output = content; // uglify-js2 variables\n\n    var ast = null;\n    var compressedAst = null;\n    var compressor = null;\n    var lintResult = null;\n    var lintData = {};\n\n    var _this = this;\n\n    var unwatched = false; // do we need to check the references?\n\n    if (this.watching) unwatched = this.checkReferences(matches); // are we linting?\n    // if so, lint the input file\n\n    if (this.lint) {\n      lintData[path.basename(this.get('inputFile'))] = this.lintFile(content);\n    } // if there is no matches, lint if required, emit nofuse event and stop processing\n\n\n    if (!matches.length && unwatched === false) {\n      // we still want to write to disk, but just the original content\n      fs.writeFile(_this.get('outputFile'), output, function (err) {\n        if (err) {\n          _this.emit('error', err);\n        } else {\n          // run the lint report\n          if (_this.lint) _this.lintReport(lintData);\n\n          _this.emit('nofuse', {\n            updated: _this.get('outputFile'),\n            fused: matches\n          });\n        }\n      });\n    } else {\n      // do we need to need lint?\n      if (this.lint) {\n        _.each(matches, function (match) {\n          // we're loading the files twice now, which isn't good\n          // need to implement a quick cache per sweep so that we can have multiple passes\n          // of file content, without multiple loads\n          var fileContent;\n          var filename = path.basename(match.path);\n          var filepath = path.join(relativePath, match.path);\n          fileContent = _this.getFileContent(filepath);\n          lintData[filename] = _this.lintFile(fileContent);\n        });\n      }\n\n      this.fuse(content, matches, relativePath, function (err, results) {\n        if (err) return _this.emit('error', err);\n        var output = results; // use uglify-js2 to minify the code if arguments are present\n\n        if (_this.compress || _this.mangle) {\n          // setup the compressor\n          compressor = ujs.Compressor({\n            warnings: false\n          }); // parse the output and create an AST\n\n          ast = ujs.parse(output); // should we compress?\n\n          if (_this.compress) {\n            ast.figure_out_scope();\n            compressedAst = ast.transform(compressor);\n          } // should we mangle?\n\n\n          if (_this.mangle) {\n            (compressedAst || ast).figure_out_scope();\n            (compressedAst || ast).compute_char_frequency();\n            (compressedAst || ast).mangle_names();\n          } // generate the new code string\n\n\n          output = (compressedAst || ast).print_to_string();\n        } // save the file to disk\n\n\n        fs.writeFile(_this.get('outputFile'), output, function (err) {\n          if (err) {\n            _this.emit('error', err);\n          } else {\n            _this.emit('fuse', {\n              updated: _this.get('outputFile'),\n              fused: matches.map(function (match) {\n                return match.path;\n              })\n            });\n          } // run the lint report\n\n\n          if (_this.lint) _this.lintReport(lintData);\n        });\n      });\n    }\n  }; // core function for parsing and generating output for a file\n\n\n  Fuse.prototype.fuseContent = function (content, relativePath, mode) {\n    // what mode are we running in, HTML or JS?\n    // this needs to be improved, because it means it will only work if the file ext is 'html' || 'js'\n    this.mode = mode; // swtich the regular expression based on mode\n\n    this.regex = this.mode === 'js' ? this.reJS : this.reHTML; // grab a list of the referenced files\n\n    var matches = this.getReferencedFiles(content, this.regex),\n        // output is a version of the content that we'll update\n    output = content,\n        _this = this; // do we have anything to combine?\n\n\n    if (!matches.length) {\n      return this.emit('nofuse', {\n        updated: content,\n        fused: matches\n      });\n    }\n\n    this.fuse(content, matches, relativePath, function (err, results) {\n      if (err) {\n        return _this.emit('error', err);\n      }\n\n      _this.emit('fuse', {\n        updated: results,\n        fused: matches.map(function (match) {\n          return match.path;\n        })\n      });\n    });\n  }; // lower-level to simply fuse the content provided a bunch of matches\n\n\n  Fuse.prototype.fuse = function (content, matches, relativePath, callback) {\n    var output = content,\n        _this = this; // loop through each match, grab the file content\n\n\n    _.each(matches, function (match) {\n      // ok, determine the file name\n      var fileContent;\n      var filename = path.basename(match.path);\n      var filepath = path.join(relativePath, match.path);\n      fileContent = _this.getFileContent(filepath); // let's replace the match with the filecontent\n\n      output = output.replace(match.str, fileContent);\n    });\n\n    callback(null, output);\n  };\n\n  Fuse.prototype.lintReport = function (lintData) {\n    var buffer = ''; // loop through the linting results and output any suggestions\n\n    for (var file in lintData) {\n      // skip the files that didn't contain errors\n      if (lintData[file] !== true) {\n        buffer += colors.red(file) + ' contains lint:'.red + '\\n';\n\n        for (var err in lintData[file]) {\n          lintData[file][err].evidence = lintData[file][err].evidence.trim();\n          buffer += mustache.render('   Error on line {{line}} at position {{character}}, {{reason}} \\'' + '{{evidence}}'.magenta + '\\'\\n', lintData[file][err]);\n        }\n      }\n    }\n\n    if (buffer.length) {\n      this.emit('lint', buffer + '\\r');\n    }\n  };\n\n  Fuse.prototype.lintFile = function (content) {\n    var lintResult = jshint(content);\n    return lintResult || jshint.errors;\n  }; // watch the input file for changes, if it does, we need to compile a new output file\n\n\n  Fuse.prototype.watchFile = function (inputFile) {\n    var _this = this,\n        inputFileName = path.basename(inputFile);\n\n    fs.watchFile(inputFile, {\n      'persistent': true,\n      'interval': 1000\n    }, function (curr, prev) {\n      if (curr.mtime.getTime() !== prev.mtime.getTime()) {\n        _this.emit('change', inputFileName);\n\n        _this.fuseFile();\n      }\n    });\n\n    _this.emit('watch', inputFile);\n  }; // watch a referenced file for changes, if it does, we need to compile a new output file\n\n\n  Fuse.prototype.watchSrcFile = function (srcFile) {\n    var _this = this,\n        srcFileName = path.basename(srcFile);\n\n    fs.watchFile(srcFile, {\n      'persistent': true,\n      'interval': 1000\n    }, function (curr, prev) {\n      if (curr.mtime.getTime() !== prev.mtime.getTime()) {\n        _this.emit('change', srcFileName);\n\n        _this.fuseFile();\n      }\n    });\n\n    _this.emit('watch', srcFile);\n  }; // unwatch a referenced file for changes\n\n\n  Fuse.prototype.unwatchSrcFile = function (srcFile) {\n    var _this = this,\n        srcFileName = path.basename(srcFile);\n\n    fs.unwatchFile(srcFile);\n\n    _this.emit('unwatch', srcFile);\n  }; // we assume this file has been verified by loadFile\n\n\n  Fuse.prototype.getFileContent = function (inputFile) {\n    try {\n      return fs.readFileSync(inputFile, 'utf-8');\n    } catch (e) {\n      this.emit('error', e);\n      return '';\n    }\n  }; // get a list of the files to include, from the input file\n\n\n  Fuse.prototype.getReferencedFiles = function (content, regex) {\n    var paths = [];\n    var matches = content.match(regex);\n\n    _.each(matches, function (match) {\n      // ok, determine the file name\n      var filepath = match.replace(regex, '$1'); // return the filepath, and the original string\n\n      paths.push({\n        'path': filepath,\n        \"str\": match\n      });\n    });\n\n    return paths;\n  }; // return only the filename, removing the actual file path\n\n\n  Fuse.prototype.getFileName = function (path) {\n    return path.replace(/.*\\/(.*)/i, '$1');\n  }; // export the class\n\n\n  exports.Fuse = Fuse; // export a helper function to instantiate the Fuse class\n\n  exports.fuse = function (inputFile, outputFile, compress, mangle, lint) {\n    var fuser = new Fuse();\n    if (inputFile) fuser.set('inputFile', inputFile);\n    if (outputFile) fuser.set('outputFile', outputFile);\n    if (compress) fuser.set('compress', compress);\n    if (mangle) fuser.set('mangle', compress);\n    if (lint) fuser.set('lint', lint);\n    return fuser;\n  };\n})();","map":{"version":3,"sources":["/home/harsha/Desktop/ug2 spring SEM2/DAss/mongo/frontend/node_modules/fuse/lib/fuse.js"],"names":["colors","require","fs","_","path","ujs","jshint","JSHINT","sys","mustache","util","EventEmitter","Fuse","settings","re","reJS","reHTML","watching","files","inherits","prototype","set","setting","val","get","watch","inputFile","outputFile","fuseImmediately","_this","arguments","length","undefined","Error","mode","extname","replace","regex","aFiles","scanFiles","relativePath","dirname","each","watchSrcFile","push","watchFile","fuseFile","getReferencedFiles","getFileContent","checkReferences","references","unwatched","forEach","reference","found","some","file","resolve","unwatchSrcFile","formatTime","d","Date","getHours","getMinutes","getSeconds","join","compress","mangle","lint","content","normalize","matches","output","ast","compressedAst","compressor","lintResult","lintData","basename","lintFile","writeFile","err","emit","lintReport","updated","fused","match","fileContent","filename","filepath","fuse","results","Compressor","warnings","parse","figure_out_scope","transform","compute_char_frequency","mangle_names","print_to_string","map","fuseContent","callback","str","buffer","red","evidence","trim","render","magenta","errors","inputFileName","curr","prev","mtime","getTime","srcFile","srcFileName","unwatchFile","readFileSync","e","paths","getFileName","exports","fuser"],"mappings":"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","sourcesContent":["(function () {\n\n\"use strict\";\n\nvar colors = require('colors');\nvar fs = require('fs');\nvar _ = require('underscore');\nvar path = require('path');\nvar ujs = require('uglify-js');\nvar jshint = require('jshint').JSHINT;\nvar sys = require('sys');\nvar mustache = require('./mustache.js');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\nfunction Fuse () {\n\n\tthis.settings = {};\n\n\t// setup the regular expressions\n\tthis.re = this.reJS = /\\/\\/ ?@(?:depends|import|include) (.+)\\b/gi;\n\tthis.reHTML = /<!--\\s?@(?:depends|import|include)\\s(.+?)\\s?-->/gi;\n\n\t// not watching by default\n\tthis.watching = false;\n\n\t// create an array to hold the watches for this fuse\n\tthis.files = [];\n\n\treturn this;\n\n}\n\nutil.inherits(Fuse, EventEmitter);\n\nFuse.prototype.set = function (setting, val) {\n\n\tthis.settings[setting] = val;\n\n\treturn this;\n\n};\n\nFuse.prototype.get = function (setting) {\n\n\treturn this.settings[setting];\n\n};\n\nFuse.prototype.watch = function (inputFile, outputFile, fuseImmediately) {\n\n\tvar _this = this;\n\n\tif (arguments.length === 1) {\n\t\tfuseImmediately = inputFile;\n\t\tinputFile = undefined;\n\t}\n\n\tif (inputFile) this.set('inputFile', inputFile);\n\tif (outputFile) this.set('outputFile', outputFile);\n\n\tif (this.get('inputFile') === undefined) throw new Error('You must define the input file.');\n\tif (this.get('outputFile') === undefined) throw new Error('You must define the output file.');\n\n\t// what mode are we running in, HTML or JS?\n\t// this needs to be improved, because it means it will only work if the file ext is 'html' || 'js'\n\tthis.mode = path.extname(this.get('inputFile')).replace(/^\\./, '');\n\t// swtich the regular expression based on mode\n\tthis.regex = (this.mode === 'js') ? this.reJS : this.reHTML;\n\t// define the watching mode\n\tthis.watching = true;\n\n\t// retrieve a list of files to watch\n\tvar aFiles = this.scanFiles();\n\tvar relativePath = path.dirname(this.get('inputFile')) + '/';\n\n\t// loop through an setup a watch on each referenced file\n\t_(aFiles).each(function (path) {\n\n\t\t_this.watchSrcFile(relativePath + path.path);\n\t\t_this.files.push(relativePath + path.path);\n\t});\n\t\n\t// we also need to watch the input file\n\tthis.watchFile(this.get('inputFile'));\n\tthis.files.push(this.get('inputFile'));\n\n\tif (fuseImmediately) this.fuseFile();\n\n\treturn this;\n\n};\n\n\n\nFuse.prototype.scanFiles = function () {\n\n\treturn this.getReferencedFiles(this.getFileContent(this.get('inputFile')), this.regex);\n\n};\n\nFuse.prototype.checkReferences = function (references) {\n\n\tvar _this = this,\n\t\tfiles = [this.get('inputFile')],\n\t\trelativePath = path.dirname(this.get('inputFile')) + '/',\n\t\tunwatched = false;\n\n\t// find references that are missing from files (these are files that need to be watched)\n\treferences.forEach(function (reference) {\n\n\t\tvar found = _this.files.some(function (file) {\n\t\t\treturn path.resolve(file) === path.resolve(relativePath, reference.path);\n\t\t});\n\n\t\t// add the file regardless if its found or not, because we're rebulding the files array\n\t\tfiles.push(relativePath + reference.path);\n\n\t\t// if the file is in the files array, let's add it and start watching\n\t\tif (!found) _this.watchSrcFile(relativePath + reference.path);\n\n\t});\n\n\t// find files that are missing from references (this are files that need to be unwatched)\n\tthis.files.forEach(function (file) {\n\n\t\t// ignore the input file, we've already added this\n\t\tif (file === _this.get('inputFile')) return;\n\n\t\t// search for this file in references\n\t\tvar found = references.some(function (reference) {\n\t\t\treturn path.resolve(file) === path.resolve(relativePath, reference.path);\n\t\t});\n\n\t\t// references is newer then file, so it may have been removed\n\t\tif (!found) {\n\t\t\t_this.unwatchSrcFile(file);\n\t\t\tunwatched = true;\n\t\t}\n\n\t});\n\n\t// update the old array, with the new one\n\tthis.files = files;\n\n\treturn unwatched;\n\n};\n\nFuse.prototype.formatTime = function () {\n\n\tvar d = new Date();\n\n\treturn [\n\t\td.getHours(),\n\t\t':',\n\t\td.getMinutes(),\n\t\t'.',\n\t\td.getSeconds()\n\t].join('');\n\n};\n\n// core function for parsing and outputing a fused file\n// uses fuseContent to do the heavy lifting\nFuse.prototype.fuseFile = function (inputFile, outputFile) {\n\n\tif (inputFile !== undefined) this.set('inputFile', inputFile);\n\tif (outputFile !== undefined) this.set('outputFile', outputFile);\n\n\tif (this.get('inputFile') === undefined) throw new Error('You must define the input file.');\n\tif (this.get('outputFile') === undefined) throw new Error('You must define the output file.');\n\n\t// what mode are we running in, HTML or JS?\n\t// this needs to be improved, because it means it will only work if the file ext is 'html' || 'js'\n\tthis.mode = path.extname(this.get('inputFile')).replace(/^\\./, '');\n\t// swtich the regular expression based on mode\n\tthis.regex = (this.mode === 'js') ? this.reJS : this.reHTML;\n\n\t// work out the settings\n\t// do we need to compress (js only)?\n\tthis.compress = (this.get('compress') !== undefined) ? this.get('compress') && this.mode === 'js' : false;\n\t// do we need to mangle (js only)?\n\tthis.mangle = (this.get('mangle') !== undefined) ? this.get('mangle') && this.mode === 'js' : false;\n\t// do we need to run the files through JSHint (js only)?\n\tthis.lint = (this.get('lint') !== undefined) ? this.get('lint') && this.mode === 'js' : false;\n\n\t// grab the content of the input file\n\tvar content = this.getFileContent(this.get('inputFile'));\n\t// determine the relative path we need to work from\n\tvar relativePath = path.dirname(path.normalize(this.get('inputFile')));\n\t// grab a list of the referenced files\n\tvar matches = this.getReferencedFiles(content, this.regex);\n\t// output is a version of the content that we'll update\n\tvar output = content;\n\n\t// uglify-js2 variables\n\tvar ast = null;\n\tvar compressedAst = null;\n\tvar compressor = null;\n\tvar lintResult = null;\n\tvar lintData = {};\n\tvar _this = this;\n\tvar unwatched = false;\n\n\t// do we need to check the references?\n\tif (this.watching) unwatched = this.checkReferences(matches);\n\n\t// are we linting?\n\t// if so, lint the input file\n\tif (this.lint) {\n\t\tlintData[path.basename(this.get('inputFile'))] = this.lintFile(content);\n\t}\n\n\t// if there is no matches, lint if required, emit nofuse event and stop processing\n\tif (!matches.length && unwatched === false) {\n\n\t\t// we still want to write to disk, but just the original content\n\t\tfs.writeFile(_this.get('outputFile'), output, function (err) {\n\n\t\t\tif (err) {\n\n\t\t\t\t_this.emit('error', err);\n\n\t\t\t} else {\n\n\t\t\t\t// run the lint report\n\t\t\t\tif (_this.lint) _this.lintReport(lintData);\n\n\t\t\t\t_this.emit('nofuse', {\n\t\t\t\t\tupdated: _this.get('outputFile'),\n\t\t\t\t\tfused: matches\n\t\t\t\t});\n\n\t\t\t}\n\n\t\t});\n\n\t} else {\n\n\t\t// do we need to need lint?\n\t\tif (this.lint) {\n\n\t\t\t_.each(matches, function (match) {\n\n\t\t\t\t// we're loading the files twice now, which isn't good\n\t\t\t\t// need to implement a quick cache per sweep so that we can have multiple passes\n\t\t\t\t// of file content, without multiple loads\n\t\t\t\tvar fileContent;\n\t\t\t\tvar filename = path.basename(match.path);\n\t\t\t\tvar filepath = path.join(relativePath,match.path);\n\n\t\t\t\tfileContent = _this.getFileContent(filepath);\n\n\t\t\t\tlintData[filename] = _this.lintFile(fileContent);\n\n\t\t\t});\n\n\t\t}\n\n\t\tthis.fuse(content, matches, relativePath, function (err, results) {\n\n\t\t\tif (err) return _this.emit('error', err);\n\n\t\t\tvar output = results;\n\n\t\t\t// use uglify-js2 to minify the code if arguments are present\n\t\t\tif (_this.compress || _this.mangle) {\n\n\t\t\t\t// setup the compressor\n\t\t\t\tcompressor = ujs.Compressor({warnings: false});\n\n\t\t\t\t// parse the output and create an AST\n\t\t\t\tast = ujs.parse(output);\n\n\t\t\t\t// should we compress?\n\t\t\t\tif (_this.compress) {\n\t\t\t\t\tast.figure_out_scope();\n\t\t\t\t\tcompressedAst = ast.transform(compressor);\n\t\t\t\t}\n\n\t\t\t\t// should we mangle?\n\t\t\t\tif (_this.mangle) {\n\t\t\t\t\t(compressedAst || ast).figure_out_scope();\n\t\t\t\t\t(compressedAst || ast).compute_char_frequency();\n\t\t\t\t\t(compressedAst || ast).mangle_names();\n\t\t\t\t}\n\n\t\t\t\t// generate the new code string\n\t\t\t\toutput = (compressedAst || ast).print_to_string();\n\n\t\t\t}\n\t\t\t\n\t\t\t// save the file to disk\n\t\t\tfs.writeFile(_this.get('outputFile'), output, function (err) {\n\n\t\t\t\tif (err) {\n\n\t\t\t\t\t_this.emit('error', err);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_this.emit('fuse', {\n\t\t\t\t\t\tupdated: _this.get('outputFile'),\n\t\t\t\t\t\tfused: matches.map(function (match) {\n\t\t\t\t\t\t\treturn match.path\n\t\t\t\t\t\t})\n\t\t\t\t\t});\n\n\t\t\t\t}\n\n\t\t\t\t// run the lint report\n\t\t\t\tif (_this.lint) _this.lintReport(lintData);\n\n\t\t\t});\n\n\t\t});\n\n\t}\n\n};\n\n// core function for parsing and generating output for a file\nFuse.prototype.fuseContent = function (content, relativePath, mode) {\n\n\t// what mode are we running in, HTML or JS?\n\t// this needs to be improved, because it means it will only work if the file ext is 'html' || 'js'\n\tthis.mode = mode;\n\t// swtich the regular expression based on mode\n\tthis.regex = (this.mode === 'js') ? this.reJS : this.reHTML;\n\n\t// grab a list of the referenced files\n\tvar matches = this.getReferencedFiles(content, this.regex),\n\t// output is a version of the content that we'll update\n\t\toutput = content,\n\t\t_this = this;\n\n\t// do we have anything to combine?\n\tif (!matches.length) {\n\t\treturn this.emit('nofuse', {\n\t\t\tupdated: content,\n\t\t\tfused: matches\n\t\t});\n\t}\n\n\tthis.fuse(content, matches, relativePath, function (err, results) {\n\n\t\tif (err) {\n\t\t\treturn _this.emit('error', err);\n\t\t}\n\n\t\t_this.emit('fuse', {\n\t\t\tupdated: results,\n\t\t\tfused: matches.map(function (match) {\n\t\t\t\treturn match.path\n\t\t\t})\n\t\t});\n\n\t});\n\n};\n\n// lower-level to simply fuse the content provided a bunch of matches\nFuse.prototype.fuse = function (content, matches, relativePath, callback) {\n\n\tvar output = content,\n\t\t_this = this;\n\n\t// loop through each match, grab the file content\n\t_.each(matches, function (match) {\n\n\t\t// ok, determine the file name\n\t\tvar fileContent;\n\t\tvar filename = path.basename(match.path);\n\t\tvar filepath = path.join(relativePath,match.path);\n\n\t\tfileContent = _this.getFileContent(filepath);\n\n\t\t// let's replace the match with the filecontent\n\t\toutput = output.replace(match.str, fileContent);\n\n\t});\n\n\tcallback(null, output);\n\n};\n\nFuse.prototype.lintReport = function (lintData) {\n\n\tvar buffer = '';\n\n\t// loop through the linting results and output any suggestions\n\tfor (var file in lintData) {\n\n\t\t// skip the files that didn't contain errors\n\t\tif (lintData[file] !== true) {\n\n\t\t\tbuffer += colors.red(file) + ' contains lint:'.red + '\\n';\n\t\t\tfor (var err in lintData[file]) {\n\t\t\t\tlintData[file][err].evidence = lintData[file][err].evidence.trim();\n\t\t\t\tbuffer += mustache.render('   Error on line {{line}} at position {{character}}, {{reason}} \\'' + '{{evidence}}'.magenta + '\\'\\n', lintData[file][err]);\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tif (buffer.length) {\n\t\tthis.emit('lint', buffer + '\\r');\n\t}\n\n};\n\nFuse.prototype.lintFile = function (content) {\n\n\tvar lintResult = jshint(content);\n\treturn lintResult || jshint.errors;\n\n};\n\n// watch the input file for changes, if it does, we need to compile a new output file\nFuse.prototype.watchFile = function (inputFile) {\n\t\n\tvar _this = this,\n\t\tinputFileName = path.basename(inputFile);\n\t\n\tfs.watchFile(inputFile, {'persistent': true, 'interval': 1000}, function (curr, prev) {\n\t\t\n\t\tif (curr.mtime.getTime() !== prev.mtime.getTime()) {\n\t\t\t_this.emit('change', inputFileName);\n\t\t\t_this.fuseFile();\n\t\t}\n\t\t\n\t});\n\n\t_this.emit('watch', inputFile);\n\t\n};\n\n// watch a referenced file for changes, if it does, we need to compile a new output file\nFuse.prototype.watchSrcFile = function (srcFile) {\n\t\n\tvar _this = this,\n\t\tsrcFileName = path.basename(srcFile);\n\t\n\tfs.watchFile(srcFile, {'persistent': true, 'interval': 1000}, function (curr, prev) {\n\t\t\n\t\tif (curr.mtime.getTime() !== prev.mtime.getTime()) {\n\t\t\t_this.emit('change', srcFileName);\n\t\t\t_this.fuseFile();\n\t\t}\n\t\t\n\t});\n\n\t_this.emit('watch', srcFile);\n\t\n};\n\n// unwatch a referenced file for changes\nFuse.prototype.unwatchSrcFile = function (srcFile) {\n\t\n\tvar _this = this,\n\t\tsrcFileName = path.basename(srcFile);\n\n\tfs.unwatchFile(srcFile);\n\n\t_this.emit('unwatch', srcFile);\n\t\n};\n\n// we assume this file has been verified by loadFile\nFuse.prototype.getFileContent = function (inputFile) {\n\n\ttry {\n\t\treturn fs.readFileSync(inputFile, 'utf-8');\n\t} catch (e) {\n\t\tthis.emit('error', e);\n\t\treturn '';\n\t}\n\n}\n\n// get a list of the files to include, from the input file\nFuse.prototype.getReferencedFiles = function (content, regex) {\n\t\n\tvar paths = [];\n\tvar matches = content.match(regex);\n\n\t_.each(matches, function (match) {\n\n\t\t// ok, determine the file name\n\t\tvar filepath = match.replace(regex, '$1');\n\n\t\t// return the filepath, and the original string\n\t\tpaths.push({'path': filepath, \"str\": match});\n\n\t});\n\t\n\treturn paths;\n\t\n};\n\n// return only the filename, removing the actual file path\nFuse.prototype.getFileName = function (path) {\n\treturn path.replace(/.*\\/(.*)/i, '$1');\n};\n\n// export the class\nexports.Fuse = Fuse;\n\n// export a helper function to instantiate the Fuse class\nexports.fuse = function (inputFile, outputFile, compress, mangle, lint) {\n\n\tvar fuser = new Fuse();\n\tif (inputFile) fuser.set('inputFile', inputFile);\n\tif (outputFile) fuser.set('outputFile', outputFile);\n\tif (compress) fuser.set('compress', compress);\n\tif (mangle) fuser.set('mangle', compress);\n\tif (lint) fuser.set('lint', lint);\n\n\treturn fuser;\n\n};\n\n}());\n"]},"metadata":{},"sourceType":"script"}